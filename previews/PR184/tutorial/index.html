<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SolidStateDetectors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/installation/">Installation</a></li><li><a class="tocitem" href="../man/config_files/">Configuration Files</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Geometries (CSG)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/csg/">CSG</a></li><li><a class="tocitem" href="../man/primitives/">Primitives</a></li><li><a class="tocitem" href="../man/transformations/">Transformations</a></li></ul></li><li><a class="tocitem" href="../man/electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../man/electric_field/">Electric Field</a></li><li><a class="tocitem" href="../man/charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../man/IO/">IO</a></li></ul></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Partially-depleted-detectors"><span>Partially depleted detectors</span></a></li><li><a class="tocitem" href="#Electric-field-calculation"><span>Electric field calculation</span></a></li><li><a class="tocitem" href="#Drift-field-calculation"><span>Drift field calculation</span></a></li><li><a class="tocitem" href="#Weighting-potential-calculation"><span>Weighting potential calculation</span></a></li><li><a class="tocitem" href="#Detector-waveform-generation"><span>Detector waveform generation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-1:-Inverted-Coax-Detector"><a class="docs-heading-anchor" href="#Example-1:-Inverted-Coax-Detector">Example 1: Inverted Coax Detector</a><a id="Example-1:-Inverted-Coax-Detector-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Inverted-Coax-Detector" title="Permalink"></a></h1><pre><code class="language-julia hljs">using Plots
using SolidStateDetectors
using Unitful

T = Float32
simulation = Simulation{T}(SSD_examples[:InvertedCoax])

plot(simulation.detector)</code></pre><p><a href="../tutorial_det.pdf"><img src="../tutorial_det.svg" alt="tutorial_det"/></a></p><p>One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):</p><pre><code class="language-julia hljs">apply_initial_state!(simulation, ElectricPotential) # optional
plot(
    plot(simulation.electric_potential), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.q_eff_imp), # charge density distribution
    plot(simulation.ϵ_r), # dielectric distribution
    layout = (1, 4), size = (1600, 500)
)</code></pre><p><a href="../tutorial_initial_condition.pdf"><img src="../tutorial_initial_condition.svg" alt="tutorial_initial_condition"/></a></p><p>Next, calculate the electric potential:</p><pre><code class="language-julia hljs">calculate_electric_potential!( simulation,
                               refinement_limits = [0.2, 0.1, 0.05, 0.01])

plot(
    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.q_eff_imp), # charge density distribution
    plot(simulation.ϵ_r), # dielectric distribution
    layout = (1, 4), size = (1600, 500)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation: Public Inverted Coax
Electric Potential Calculation
Bias voltage: 3500.0 V
φ symmetry: Detector is φ-symmetric -&gt; 2D computation.
Precision: Float32
Convergence limit: 1.0e-7 =&gt; 0.00035 V
Threads: 1
Coordinate system: Cylindrical
N Refinements: -&gt; 4
Initial grid size: (12, 1, 10)

Grid size: (18, 1, 20)
Grid size: (32, 1, 42)
Grid size: (60, 1, 88)
Grid size: (270, 1, 388)</code></pre><p><a href="../tutorial_calculated_potential.pdf"><img src="../tutorial_calculated_potential.svg" alt="tutorial_calculated_potential"/></a></p><p>SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:</p><pre><code class="language-julia hljs">get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">239.09152f0 cm^3</code></pre><h2 id="Partially-depleted-detectors"><a class="docs-heading-anchor" href="#Partially-depleted-detectors">Partially depleted detectors</a><a id="Partially-depleted-detectors-1"></a><a class="docs-heading-anchor-permalink" href="#Partially-depleted-detectors" title="Permalink"></a></h2><p>SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:</p><pre><code class="language-julia hljs">simulation_undep = deepcopy(simulation)
simulation_undep.detector = SolidStateDetector(simulation_undep.detector, contact_id = 2, contact_potential = 500); # V  &lt;-- Bias Voltage of Mantle

calculate_electric_potential!( simulation_undep,
                               depletion_handling = true,
                               convergence_limit=1e-6,
                               refinement_limits = [0.2, 0.1, 0.05, 0.01],
                               verbose = false)


plot(
    plot(simulation_undep.electric_potential),
    plot(simulation_undep.point_types),
    layout = (1, 2), size = (800, 700)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Maximum number of iterations reached. (`n_iterations = 51000`)
[ Info: Maximum number of iterations reached. (`n_iterations = 51000`)
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.00003 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:492
[ Info: Maximum number of iterations reached. (`n_iterations = 51000`)
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.00006 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:492
Checking undepleted regions  40%|█████████▎             |  ETA: 0:00:00Checking undepleted regions 100%|███████████████████████| Time: 0:00:00
Checking undepleted regions  40%|█████████▎             |  ETA: 0:00:00Checking undepleted regions  80%|██████████████████▍    |  ETA: 0:00:00Checking undepleted regions 100%|███████████████████████| Time: 0:00:00
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.00034 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:492</code></pre><p><a href="../tutorial_calculated_potential_undep.pdf"><img src="../tutorial_calculated_potential_undep.svg" alt="tutorial_calculated_potential_undep"/></a></p><p>Compare both volumes:</p><pre><code class="language-julia hljs">println(&quot;Depleted:   &quot;, get_active_volume(simulation.point_types))
println(&quot;Undepleted: &quot;, get_active_volume(simulation_undep.point_types));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Depleted:   239.09152f0 cm^3
Undepleted: 157.17224f0 cm^3</code></pre><h2 id="Electric-field-calculation"><a class="docs-heading-anchor" href="#Electric-field-calculation">Electric field calculation</a><a id="Electric-field-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-field-calculation" title="Permalink"></a></h2><p>Calculate the electric field of the fully depleted detector, given the already calculated electric potential:</p><pre><code class="language-julia hljs">calculate_electric_field!(simulation, n_points_in_φ = 72)

plot(simulation.electric_field, full_det = true, φ = 0.0, size = (500, 500))
plot_electric_fieldlines!(simulation, full_det = true, φ = 0.0)</code></pre><p><a href="../tutorial_electric_field.pdf"><img src="../tutorial_electric_field.svg" alt="tutorial_electric_field"/></a></p><h2 id="Drift-field-calculation"><a class="docs-heading-anchor" href="#Drift-field-calculation">Drift field calculation</a><a id="Drift-field-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Drift-field-calculation" title="Permalink"></a></h2><p>Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:</p><p>Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the Bruyneel model from the Agata Data Library (ADL) is used. Other configurations are saved in their configuration files and can be found under:</p><p><code>&lt;package_directory&gt;/examples/example_config_files/ADLChargeDriftModel/&lt;config_filename&gt;.yaml.</code></p><p>Set the charge drift model of the simulation:</p><pre><code class="language-julia hljs">charge_drift_model = ADLChargeDriftModel()
simulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"></code></pre><p>And apply the charge drift model to the electric field:</p><pre><code class="language-julia hljs">calculate_drift_fields!(simulation)</code></pre><p>Now, let&#39;s create an &quot;random&quot; (multiside) event:</p><pre><code class="language-julia hljs">starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),
                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),
                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]
energy_depos = T[1460, 609, 1000] * u&quot;keV&quot; # are needed later in the signal generation

event = Event(starting_positions, energy_depos);

time_step = 5u&quot;ns&quot;
drift_charges!(event, simulation, Δt = time_step)

plot(simulation.detector, size = (700, 700))
plot!(event.drift_paths)</code></pre><p><a href="../tutorial_drift_paths.pdf"><img src="../tutorial_drift_paths.svg" alt="tutorial_drift_paths"/></a></p><h2 id="Weighting-potential-calculation"><a class="docs-heading-anchor" href="#Weighting-potential-calculation">Weighting potential calculation</a><a id="Weighting-potential-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Weighting-potential-calculation" title="Permalink"></a></h2><p>We need weighting potentials to simulate the detector charge signal induced by drifting charges. We&#39;ll calculate the weighting potential for the point contact and the outer shell of the detector:</p><pre><code class="language-julia hljs">for contact in simulation.detector.contacts
    calculate_weighting_potential!(simulation, contact.id, refinement_limits = [0.2, 0.1, 0.05, 0.01], n_points_in_φ = 2, verbose = false)
end

plot(
    plot(simulation.weighting_potentials[1]),
    plot(simulation.weighting_potentials[2]),
    size = (900, 700)
)</code></pre><p><a href="../tutorial_weighting_potentials.pdf"><img src="../tutorial_weighting_potentials.svg" alt="tutorial_weighting_potentials"/></a></p><h2 id="Detector-waveform-generation"><a class="docs-heading-anchor" href="#Detector-waveform-generation">Detector waveform generation</a><a id="Detector-waveform-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Detector-waveform-generation" title="Permalink"></a></h2><h3 id="Single-event-simulation"><a class="docs-heading-anchor" href="#Single-event-simulation">Single-event simulation</a><a id="Single-event-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Single-event-simulation" title="Permalink"></a></h3><p>Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):</p><pre><code class="language-julia hljs">simulate!(event, simulation) # drift_charges + signal generation of all channels

p_pc_signal = plot( event.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = &quot;Time / ns&quot;,
                    legend = false, tickfontsize = 12, ylabel = &quot;Energy / eV&quot;, guidefontsize = 14)</code></pre><p><a href="../tutorial_waveforms.pdf"><img src="../tutorial_waveforms.svg" alt="tutorial_waveforms"/></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../man/IO/">« IO</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Wednesday 21 July 2021 14:00">Wednesday 21 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
