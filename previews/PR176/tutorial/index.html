<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SolidStateDetectors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Detectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/config_files/">Configuration Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Geometries (CSG)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/csg/">CSG</a></li><li><a class="tocitem" href="../man/primitives/">Primitives</a></li></ul></li><li><a class="tocitem" href="../man/electric_potentials/">Electric Potentials</a></li><li><a class="tocitem" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../man/electric_fields/">Electric Fields</a></li><li><a class="tocitem" href="../man/drift_fields/">Drift Fields</a></li><li><a class="tocitem" href="../man/IO/">IO</a></li></ul></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Partially-depleted-detectors"><span>Partially depleted detectors</span></a></li><li><a class="tocitem" href="#Electric-field-calculation"><span>Electric field calculation</span></a></li><li><a class="tocitem" href="#Drift-field-calculation"><span>Drift field calculation</span></a></li><li><a class="tocitem" href="#Weighting-potential-calculation"><span>Weighting potential calculation</span></a></li><li><a class="tocitem" href="#Detector-waveform-generation"><span>Detector waveform generation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-1:-Inverted-Coax-Detector"><a class="docs-heading-anchor" href="#Example-1:-Inverted-Coax-Detector">Example 1: Inverted Coax Detector</a><a id="Example-1:-Inverted-Coax-Detector-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Inverted-Coax-Detector" title="Permalink"></a></h1><pre><code class="language-julia">using Plots
using SolidStateDetectors
using Unitful

T = Float32
simulation = Simulation{T}(SSD_examples[:InvertedCoax])

plot(simulation.detector)</code></pre><p><a href="../tutorial_det.pdf"><img src="../tutorial_det.svg" alt="tutorial_det"/></a></p><p>One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):</p><pre><code class="language-julia">apply_initial_state!(simulation, ElectricPotential) # optional
plot(
    plot(simulation.electric_potential), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.q_eff_imp), # charge density distribution
    plot(simulation.ϵ_r), # dielectric distribution
    layout = (1, 4), size = (1600, 500)
)</code></pre><p><a href="../tutorial_initial_condition.pdf"><img src="../tutorial_initial_condition.svg" alt="tutorial_initial_condition"/></a></p><p>Next, calculate the electric potential:</p><pre><code class="language-julia">calculate_electric_potential!( simulation,
                               max_refinements = 3)

plot(
    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.q_eff_imp), # charge density distribution
    plot(simulation.ϵ_r), # dielectric distribution
    layout = (1, 4), size = (1600, 500)
)</code></pre><pre class="documenter-example-output">Electric Potential Calculation
Bias voltage: 3500.0 V
φ symmetry: Detector is φ-symmetric -&gt; 2D computation.
Precision: Float32
Convergence limit: 1.0e-7 =&gt; 0.00035 V
Threads: 1
Coordinate system: Cylindrical
Initial grid dimension: (15, 1, 18)
Refine? -&gt; true
Refinement parameters:
	maximum number of refinements: 3
	minimum grid spacing:
		r: 1.0e-5 m
		φ: 0.0009999999 rad
		z: 1.0e-5 m
	Refinement limits:
		r: 1.0e-5 -&gt; 0.035 V
		φ: 0.0009999999 -&gt; 3.5 V
		z: 1.0e-5 -&gt; 0.035 V

[ Info: Maximum number of iterations reached. (`n_iterations = 74074`)
[ Info: New Grid Size = (29, 1, 34)
[ Info: Maximum number of iterations reached. (`n_iterations = 50705`)
[ Info: New Grid Size = (57, 1, 66)
[ Info: New Grid Size = (113, 1, 130)</pre><p><a href="../tutorial_calculated_potential.pdf"><img src="../tutorial_calculated_potential.svg" alt="tutorial_calculated_potential"/></a></p><p>SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:</p><pre><code class="language-julia">get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)</code></pre><pre class="documenter-example-output">233.59344f0 cm^3</pre><h2 id="Partially-depleted-detectors"><a class="docs-heading-anchor" href="#Partially-depleted-detectors">Partially depleted detectors</a><a id="Partially-depleted-detectors-1"></a><a class="docs-heading-anchor-permalink" href="#Partially-depleted-detectors" title="Permalink"></a></h2><p>SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:</p><pre><code class="language-julia">simulation_undep = deepcopy(simulation)
simulation_undep.detector = SolidStateDetector(simulation_undep.detector, contact_id = 2, contact_potential = 500); # V  &lt;-- Bias Voltage of Mantle

calculate_electric_potential!( simulation_undep,
                               depletion_handling = true,
                               convergence_limit=1e-6,
                               max_refinements = 3,
                               verbose = false)


plot(
    plot(simulation_undep.electric_potential),
    plot(simulation_undep.point_types),
    layout = (1, 2), size = (800, 700)
)</code></pre><pre class="documenter-example-output">[ Info: Maximum number of iterations reached. (`n_iterations = 74074`)
[ Info: Maximum number of iterations reached. (`n_iterations = 74074`)
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.00003 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:563
[ Info: Maximum number of iterations reached. (`n_iterations = 50705`)
[ Info: Maximum number of iterations reached. (`n_iterations = 50502`)
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.0002 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:563
┌ Warning: Detector seems not to be not fully depleted at a bias voltage of 500.0 V.
│ At least one grid point has a higher potential value (500.00018 V)
│ than the maximum applied potential (500.0 V). This should not be.
│ However, small overshoots could be due to numerical precision.
└ @ SolidStateDetectors ~/work/SolidStateDetectors.jl/SolidStateDetectors.jl/src/Simulation/Simulation.jl:563</pre><p><a href="../tutorial_calculated_potential_undep.pdf"><img src="../tutorial_calculated_potential_undep.svg" alt="tutorial_calculated_potential_undep"/></a></p><p>Compare both volumes:</p><pre><code class="language-julia">println(&quot;Depleted:   &quot;, get_active_volume(simulation.point_types))
println(&quot;Undepleted: &quot;, get_active_volume(simulation_undep.point_types));</code></pre><pre class="documenter-example-output">Depleted:   233.59344f0 cm^3
Undepleted: 146.50467f0 cm^3</pre><h2 id="Electric-field-calculation"><a class="docs-heading-anchor" href="#Electric-field-calculation">Electric field calculation</a><a id="Electric-field-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-field-calculation" title="Permalink"></a></h2><p>Calculate the electric field of the fully depleted detector, given the already calculated electric potential:</p><pre><code class="language-julia">calculate_electric_field!(simulation, n_points_in_φ = 72)

plot(simulation.electric_field, full_det = true, φ = 0.0, size = (500, 500))
plot_electric_fieldlines!(simulation, full_det = true, φ = 0.0)</code></pre><p><a href="../tutorial_electric_field.pdf"><img src="../tutorial_electric_field.svg" alt="tutorial_electric_field"/></a></p><h2 id="Drift-field-calculation"><a class="docs-heading-anchor" href="#Drift-field-calculation">Drift field calculation</a><a id="Drift-field-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Drift-field-calculation" title="Permalink"></a></h2><p>Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:</p><p>Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the Bruyneel model from the Agata Data Library (ADL) is used. Other configurations are saved in their configuration files and can be found under:</p><p><code>&lt;package_directory&gt;/examples/example_config_files/ADLChargeDriftModel/&lt;config_filename&gt;.yaml.</code></p><p>Set the charge drift model of the simulation:</p><pre><code class="language-julia">charge_drift_model = ADLChargeDriftModel()
simulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)</code></pre><pre class="documenter-example-output"></pre><p>And apply the charge drift model to the electric field:</p><pre><code class="language-julia">calculate_drift_fields!(simulation)</code></pre><p>Now, let&#39;s create an &quot;random&quot; (multiside) event:</p><pre><code class="language-julia">starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),
                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),
                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]
energy_depos = T[1460, 609, 1000] * u&quot;keV&quot; # are needed later in the signal generation

event = Event(starting_positions, energy_depos);

time_step = 5u&quot;ns&quot;
drift_charges!(event, simulation, Δt = time_step)

plot(simulation.detector, size = (700, 700))
plot!(event.drift_paths)</code></pre><p><a href="../tutorial_drift_paths.pdf"><img src="../tutorial_drift_paths.svg" alt="tutorial_drift_paths"/></a></p><h2 id="Weighting-potential-calculation"><a class="docs-heading-anchor" href="#Weighting-potential-calculation">Weighting potential calculation</a><a id="Weighting-potential-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Weighting-potential-calculation" title="Permalink"></a></h2><p>We need weighting potentials to simulate the detector charge signal induced by drifting charges. We&#39;ll calculate the weighting potential for the point contact and the outer shell of the detector:</p><pre><code class="language-julia">for contact in simulation.detector.contacts
    calculate_weighting_potential!(simulation, contact.id, max_refinements = 3, n_points_in_φ = 2, verbose = false)
end

plot(
    plot(simulation.weighting_potentials[1]),
    plot(simulation.weighting_potentials[2]),
    size = (900, 700)
)</code></pre><pre class="documenter-example-output">[ Info: Maximum number of iterations reached. (`n_iterations = 55554`)
[ Info: Maximum number of iterations reached. (`n_iterations = 52787`)</pre><p><a href="../tutorial_weighting_potentials.pdf"><img src="../tutorial_weighting_potentials.svg" alt="tutorial_weighting_potentials"/></a></p><h2 id="Detector-waveform-generation"><a class="docs-heading-anchor" href="#Detector-waveform-generation">Detector waveform generation</a><a id="Detector-waveform-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Detector-waveform-generation" title="Permalink"></a></h2><h3 id="Single-event-simulation"><a class="docs-heading-anchor" href="#Single-event-simulation">Single-event simulation</a><a id="Single-event-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Single-event-simulation" title="Permalink"></a></h3><p>Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):</p><pre><code class="language-julia">simulate!(event, simulation) # drift_charges + signal generation of all channels

p_pc_signal = plot( event.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = &quot;Time / ns&quot;,
                    legend = false, tickfontsize = 12, ylabel = &quot;Energy / eV&quot;, guidefontsize = 14)</code></pre><p><a href="../tutorial_waveforms.pdf"><img src="../tutorial_waveforms.svg" alt="tutorial_waveforms"/></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../man/IO/">« IO</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Wednesday 14 July 2021 12:18">Wednesday 14 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
