var documenterSearchIndex = {"docs":
[{"location":"man/config_files/#Configuration-Files","page":"Configuration Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detector, its surroundings and symmetries can be specified in configuration files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"SolidStateDetectors.jl supports YAML and JSON as formats for the configuration files.","category":"page"},{"location":"man/config_files/#Example-Configuration-Files","page":"Configuration Files","title":"Example Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Several example configuration files can be found under","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"<package_directory>/examples/example_config_files/.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They are accessible through a dictionary, SSD_examples, defined in the package:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"using SolidStateDetectors\r\nkeys(SSD_examples) # dictionary holding the full path to the corresponding configuration files","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They can be loaded via","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"path_to_config_file = SSD_examples[:InvertedCoax]\r\nsim = Simulation(path_to_config_file)","category":"page"},{"location":"man/config_files/#General-Structure","page":"Configuration Files","title":"General Structure","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files need a minimum of information in order to define the detector, its surroundings and symmetries.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"This is a minimum working example of a simple true coaxial detector with two contacts:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: Simple True Coax # optional\r\nunits:\r\n  length: mm\r\n  angle: deg\r\ngrid:\r\n  coordinates: cylindrical\r\n  axes:\r\n    r: 45\r\n    z:\r\n      from: -40\r\n      to: 40\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor:\r\n    material: HPGe\r\n    geometry:\r\n      tube:\r\n        r: \r\n          from: 0.5cm\r\n          to: 4cm\r\n        h: 6cm\r\n  contacts:\r\n  - material: HPGe\r\n    id: 1\r\n    potential: 6000\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 5\r\n          to: 5\r\n        h: 60\r\n  - material: HPGe\r\n    id: 2\r\n    potential: 0\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 40\r\n          to: 40\r\n        h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"It will be used to guide through the different parts of the configuration file.","category":"page"},{"location":"man/config_files/#Units","page":"Configuration Files","title":"Units","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Internally, SolidStateDetectors.jl performs its calculations in SI units. However, configuration files can be written in custom units.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The field units denotes the standard units with which values will be parsed. Standard units can be defined for length, angle, potential and temperature.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the example above, ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units:\r\n  length: mm\r\n  angle: deg","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"will lead to all length values to be parsed in units of mm, while all angle values will be parsed in units of deg (degree).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files also allow for directly passing units to the values that will be parsed using uparse from the Unitful.jl package, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units: \r\n  length: mm\r\n  # ....\r\ntube:\r\n  r: \r\n    from: 5\r\n    to: 40\r\n  h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"is equivalent to","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 5mm\r\n    to: 40mm\r\n  h: 60mm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"or","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 0.5cm\r\n    to: 4cm\r\n  h: 6cm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the last example, even if the length unit was set to mm, the values will be parsed in units of cm. Please note to not leave a white space between the value and the unit and to use the Unitful.jl notation.","category":"page"},{"location":"man/config_files/#Grid","page":"Configuration Files","title":"Grid","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The calculations are performed on a finite world. To define the world, SolidStateDetectors.jl requires the properties of the grid, which are the coordinate system type and the dimensions. These are defined in the grid section of the configuration file, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cartesian\r\n axes:\r\n   x: \r\n     from: -40\r\n     to: 40\r\n   y:\r\n     from: -40\r\n     to: 40\r\n   z:\r\n     from: -40\r\n     to: 40","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The coordinates of the grid can be:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"cartesian (with the axes x, y and z)\ncylindrical (with the axes r, phi and z).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The axes field is used to define the dimensions of each axis and, optionally, the boundary handling. In the example above, the x, y and z axes range from -40 to 40 units.","category":"page"},{"location":"man/config_files/#Grid-boundary-handling","page":"Configuration Files","title":"Grid boundary handling","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Symmetries of the world can be used to reduce the calculation only to a fraction of the world. These can be passed as boundaries to the different axes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For linear axes (x, y, z), the boundaries can be chosen infinite, periodic, reflecting, or fixed.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For radial axes (r), the boundaries can be chosen r0. If no boundaries are given, the default is r0 for the left boundary and infinite for the right boundary.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For angular axes (phi), the boundaries can be chosen reflecting or periodic. If no boundaries are given, the default is periodic for both edges.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-symmetric configurations can be calculated in 2D if phi ranges from 0 to 0 with periodic boundary handling, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0\r\n     to: 0\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-periodic configurations can be calculated on the fraction of the full 2pi interval, i.e. for a 120°-periodic system","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 120°\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Different boundary handling can be chosen for the left and right end of the interval, i.e. for a 60°-periodic system with mirror symmetry at 30°","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 30°\r\n     boundaries:\r\n       left: periodic\r\n       right: reflecting\r\n   z: #...","category":"page"},{"location":"man/config_files/#Detector-Constituents","page":"Configuration Files","title":"Detector Constituents","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detectors for the simulation are defined in an array detectors, where each entry corresponds to one detector. Each detector consists of exactly one semiconductor, a minimum of two contacts and, optionally, passives and virtual_drift_volumes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - name: \"Detector 1\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2 \r\n    passives: \r\n      - # Passive 1 (optional)\r\n    virtual_drift_volumes:\r\n      - # Virtual Drift Volume 1 (optional)\r\n  - name: \"Detector 2\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2","category":"page"},{"location":"man/config_files/#Bulk","page":"Configuration Files","title":"Bulk","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of the semiconductor looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"semiconductor:\r\n  material: HPGe\r\n  temperature: 78\r\n  impurity_density: # ...\r\n  charge_drift_model: # ...\r\n  geometry: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of the semiconductor are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"material: the material of the semiconductor. This is important to know the electric properties of the semiconductor for the electric potential calculation. Possible choices are HPGe (high-purity germanium) and Si (silicon).\ntemperature (optional): the temperature of the semiconductor. If no temperature is given, the default is 78K for germanium and 293K for all other materials.\nimpurity_density (optional): the distribution of impurities in the semiconductor material. This has a strong impact on the electric potential calculation. If no impurity_density is given, the default is an impurity-free material (rho(vecr) = 0).\ncharge_drift_model (optional): a model to describe the drift of charge carriers in the semiconductor material. If no charge_drift_model is given, the default is ElectricFieldChargeDriftModel. Find a detailed description  on how to define an own model under Custom Charge Drift Model.\ngeometry: the geometry of the semiconductor object. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Contacts","page":"Configuration Files","title":"Contacts","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of contacts looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"contacts:\r\n  - name: \"n+ contact\"\r\n    id: 1\r\n    potential: 5000V\r\n    material: HPGe # optional\r\n    geometry: # ....\r\n  - name: \"p+ contact\"\r\n    id: 2\r\n    potential: 0\r\n    material: HPGe #optional\r\n    geometry: # ....","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"where each entry of the contacts array defines one contact.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a contact are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the custom name for the contacts, relevant for plotting. \nid: a unique id of the contact that will unambiguously identify the contact, for example in the signal generation. All contacts should be given an integer id, ideally from 1 to N where N is the number of contacts.\npotential: the electric potential applied to the contact that is fixed throughout the whole contact geometry. This value can be parsed with units (5000V) or without (0 with the units defined in the units section).\nmaterial (optional): the material of the contact. This is important to know the electric properties of the contact for the electric potential calculation. If no material is given, the default is HPGe (high-purity germanium).\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Passives-and-Charged-Surfaces","page":"Configuration Files","title":"Passives and Charged Surfaces","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects and charged surfaces can be defined through entries of the passives array for each detector, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"passives:\r\n  - name: Passivated Surface\r\n    material: HPGe\r\n    charge_density: # ...\r\n    geometry: # ...\r\n  - name: Cryostat\r\n    id: 3\r\n    potential: 0\r\n    temperature: 293K\r\n    material: Al\r\n    geometry: # ...\r\n","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a passive are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the name of the passive object. If no name is given, the default name is \"external part\".\nid (optional): a unique id of the contact that will unambiguously identify the passive object. If no id is given, the default is -1.\npotential (optional): the electric potential to which the passive object is fixed. This value can be parsed with units (5000V) or without (0 with the units defined in the units section). If no potential is given, the passive object will be treated as floating. \ntemperature (optional): the temperature of the passive object. This value can be parsed with units (293K) or without (78 with the units defined in the units section). If no temperature is given, the default is 293K.\nmaterial: the material of the passive object. This is important to know the electric properties of the contact for the electric potential calculation.\ncharge_density (optional): model to describe charge density distributions within the passive object, e.g. charged surfaces. Find a detailed description on how to define charge densities under Charge Density.\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries in the section under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Surroundings","page":"Configuration Files","title":"Surroundings","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The medium of the world is passed as field medium, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"If no medium is given, the default is vacuum. Implemented media are vacuum and LAr (liquid argon), but other media can be easily added to the material_properties dictionary in  MaterialProperties.jl.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects, especially cryostats or holding structures can be defined in an array surroundings without being assigned to a specific detector. ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor: # ...\r\n  contacts: \r\n    - # ...\r\n    - # ...\r\n  passives:\r\n    - # ...\r\n    - # ...\r\nsurroundings:\r\n  - #...\r\n  - #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The definition of passive objects in the surroundings array is equal to that in the passives array of a detector.","category":"page"},{"location":"man/config_files/#Splitting-Configuration-Files","page":"Configuration Files","title":"Splitting Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Configuration files for complex geometries can get quite long. SolidStateDetectors.jl allows for splitting configuration files into smaller ones and loading them using the include keyword. This feature supports YAML and JSON files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"When including a separate file, the user has to add its file path in the main configuration file at the place it supposed to be added. To identify the file, set the key of this entry to include. Here, the user can also give an array of file paths. The file paths can be relative to the path of the configuration file or absolute. When including nested files and using relative paths, please always refer to the last parent file.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including one file:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include : \"file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including a list of files:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include: \r\n  - \"first_file_to_be_included.yaml\"\r\n  - \"second_file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Add files to an array in the main configuration file","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - include: \"first_file_in_array.yaml\"\r\n  - include: \"second_file_in_array.yaml\"\r\n  - include: \"thrid_file_in_array.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"A fully working example can be seen in SSD_examples[:InvertedCoaxInCryostat]. Here, the channels, the geometry and other parts are split into separate configuration files.","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)","page":"CSG","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"All objects are defined through Constructive Solid Geometry (CSG), where complex geometries can be constructed by combining simple volume primitives (e.g. Tube) through Boolean operators. ","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"The primitives which can be used are shown under Volume Primitives together with how they can be specified in the configuration files.","category":"page"},{"location":"man/csg/#Boolean-operators","page":"CSG","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"The Boolean operators are union, difference and intersection:","category":"page"},{"location":"man/csg/#Union","page":"CSG","title":"Union","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"A union of two objects A and B is defined as the set of points that are in at least one of either A or B. In the configuration files, it is defined using the union field, followed by an array of entries to construct the union, e.g.","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"union: # A || B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"(Image: CSGUnion)","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"If more than two geometries are passed, the union is constructed from all of them.","category":"page"},{"location":"man/csg/#Difference","page":"CSG","title":"Difference","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"A difference of two objects A and B is defined as the set of points that are in A but not in B. Note that B is treated as open primitive. This means that points which are in A and on the surface of B will still be in the difference of A and B. In the configuration files, it is defined using the difference field, followed by an array of entries. The first entry of the array is the main geometry, from which all following geometry entries are subtracted, e.g.","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"difference: # A && !B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.1","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"(Image: CSGDifference)","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"Keep in mind that to discard the part of the surface of A which is on the surface of B, B should be chosen slightly bigger than A.","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"If more than two geometries are passed, all entries starting from the second will be subtracted from the first.","category":"page"},{"location":"man/csg/#Intersection","page":"CSG","title":"Intersection","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"An intersection of two objects A and B is defined as the set of points that are both in A and in B. In the configuration files, it is defined using the intersection field, followed by an array of entries to construct the intersection, e.g.","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"intersection: # A && B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"(Image: CSGIntersection)","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"If more than two geometries are passed, the intersection is constructed from all of them.","category":"page"},{"location":"man/IO/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"After simulating the potentials and fields of a detector setup, the results should be saved to a file to avoid recalculating them every time the user starts a program.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"One easy way to do this is using JLD2.jl and FileIO.jl.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Simulation results can be saved to a JLD file using","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using SolidStateDetectors\r\nsimulation = Simulation(\"<config-file-name>\")\r\n# ...\r\n\r\nusing FileIO\r\nFileIO.save(\"<name-of-simulation-file>.jld\", Dict(\"Simulation\" => simulation)","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"It can be read back in using","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using FileIO\r\nFileIO.load(\"<name-of-simulation.file>.jld\", \"Simulation\")","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Other more compact ways of saving simulation results are based on the HDF5 saving format and the package HDF5.jl.","category":"page"},{"location":"man/charge_drift/#Charge-Drift","page":"Charge Drift","title":"Charge Drift","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Charged particles in vacuum move along the electric field lines under Coulomb's force, bmF = q bmE, where bmF corresponds to the force experienced by the particle, q is the charge of the particle and bmE is the electric field. Charged particles in vacuum would be continuously accelerated until approaching the speed of light (called ballistic transport), however, inside a material, scattering prevents this constant acceleration and leads to a constant drift velocity ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_d = mu E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where v_d is the drift velocity, mu the mobility and E the electric field strength.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The scattering with matter not only limits the absolute drift velocity, it might also deviate the trajectories from the electric field lines: e.g., in crystals, the principal axes orientation has an impact on the resulting drift trajectory. The influence of the scattering on the drift trajectories can be expressed by a 3x3 tensor, the so-called mobility tensor mu_ij, which transforms the electric field, E, into the drift field, v_i:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_i =  mu_ij cdot E_j","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The mobility varies for different materials and depends also on other parameters such as temperature, impurity density and the electric field strength, as explained later.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Electrons and holes have different mobilities, resulting in different drift fields. There are several models for the mobility tensor of electrons and holes in certain materials. Right now, two models are implemented. The first one is a pseudo-drift model, the ElectricFieldChargeDriftModel, which just takes the electric field vectors as drift vectors, see section Electric Field Charge Drift Model. The second one, ADLChargeDriftModel, is a drift model for high purity germanium, see section ADL Charge Drift Model. However, the implementation of an own model is possible and explained in section Custom Charge Drift Model.","category":"page"},{"location":"man/charge_drift/#Electric-Field-Charge-Drift-Model","page":"Charge Drift","title":"Electric Field Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ElectricFieldChargeDriftModel describes a system in which electrons and holes move along the electric field lines. In this case, the mobility is a scalar pm 1 m²/(Vs) (+ for holes, and - for electrons), and thus, the velocity field has the same (or opposite) direction as the electric field. Even though this model does not describe reality, it is useful in some cases to use the electric field vectors as velocity vectors.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to set the ElectricFieldChargeDriftModel for the simulation, the precision type of the calculation T (Float32 or Float64) has to be given as an argument. Note that T has to be of the same precision type of the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ElectricFieldChargeDriftModel(T)\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no charge drift model is specified for the semiconductor of the detector in the configuration files, the default is ElectricFieldChargeDriftModel.","category":"page"},{"location":"man/charge_drift/#ADL-Charge-Drift-Model","page":"Charge Drift","title":"ADL Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In high-purity germanium, the mobility cannot be expressed by a simple scalar quantity. Germanium has a cubic diamond lattice structure with langle100rangle, langle110rangle and langle111rangle as principal directions. Along these axes, the charge drift is parallel to the electric field. However, the longitudinal drift velocity, v_l, is not equally fast on the three axes. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"On each axes, v_l can be described through the parametrization proposed by D.M. Caughey and R.E. Thomas, which was later expanded by L. Mihailescu et al.:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The parameters mu_0, E_0 and beta differ for electrons and holes, and mu_n is only relevant for electrons. These parameters were obtained by B. Bruyneel et al. by measuring the drift velocities of electrons and holes in the langle100rangle and langle111rangle directions in high purity germanium at a temperature of 78 K. These parameters are stored in a configuration file, \"drift_velocity_config.yaml\", located in <package_directory>/example/example_config_files/ADLChargeDriftModel. The configuration file is expressed as following:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: ADLChargeDriftModel\nphi110: -0.785398\nmaterial: HPGe\ndrift:\n  velocity:\n    model: Bruyneel2006\n    parameters:\n      e100:\n        mu0: 3.8609\n        beta: 0.805\n        E0: 51100\n        mun: -0.0171\n      e111:\n        mu0: 3.8536\n        beta: 0.641\n        E0: 53800\n        mun: 0.051\n      h100:\n        mu0: 6.1824\n        beta: 0.942\n        E0: 18500\n      h111:\n        mu0: 6.1215\n        beta: 0.662\n        E0: 18200","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where the parameters are stored under the keys e100, e111, h100 and h111, in which e and h stand for electrons and holes, respectively, and 100 and 111, for the principal axes langle100rangle and langle111rangle.  By default, in SolidStateDetectors.jl the langle001rangle axis is aligned with the Z-axis of the coordinate system of the simulation. The crystal orientation can be set through the phi110 parameter, where the langle001rangle axis is still aligned with the Z-axis and the angle between the langle110rangle principal direction of the crystal and the X-axis is given by phi110. Alternatively, the crystal orientation can be set by passing a rotation matrix that describes the rotation from the global coordinate system to the crystal orientation system.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If the electric field is not aligned with any of the crystal axes, the charge drift velocity is not necessarily aligned with the electric field. In the ADLChargeDriftModel, two models are implemented to describe the charge drift of electrons and holes between the axes. Detailed information about the charge drift models is provided in the papers from L. Mihailescu et al.  for electrons and from B.Bruyneel et al. for holes. Find the detailed calculations and modifications from the publications as implemented in SolidStateDetectors.jl here.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to perform the calculation of the drift fields, a configuration file containing the parametrization values like the \"drift_velocity_config.yaml\" (with Bruyneel's data or modified values), has to be passed as an argument to the ADLChargeDriftModel function. The precision of the the calculation T (Float32 or Float64) has to be given as a keyword T. Note that T has to be of the same type as the chosen in the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_ADL_configuration_file>\", T=T)\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ÀDLChargeDriftModel can also be specified already in the configuration file as field charge_drift_model of the semiconductor of a detector, e.g.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      phi110: -0.785398 # in radians if no units are given\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"or","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      crystal_orientation:\n        X: 45° # crystal axes correspond to the global xyz coordinate system, rotated 45° around the x axis\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The charge_drift_model needs:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: the name of the charge drift model, which in this case is ADLChargeDriftModel\nphi110 or crystal_orientation: the description of the orientation of the crystal with respect to the global coordinate system. When using phi110, the \\langle001\\rangle axis is aligned with the global z axis and phi110 describes the angle between the langle110rangle axis and the x axis in radians (counterclockwise, looking from the top). If the langle001rangle axis is not aligned with the z axis, a rotation matrix to transform the global coordinate system to the crystal axes system can be given.\nmaterial (optional): the semiconductor material. If no material is given, the material of the semiconductor is taken by default.\ndrift: the parameters needed to describe the longitudinal drift velocity along the langle100rangle and langle111rangle axes, see above.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The values from the default configuration file correspond to germanium at 78 K. Calculations of the drift field at other temperatures are also supported by the ADLChargeDriftModel. While experimental observations suggest that the charge mobilities of electrons and holes in the crystal are temperature dependent, the dependency law has not yet been established. Several models have been proposed to reproduce the experimental behavior, and some examples of them can be found in the directory <package_directory>/src/ChargeDriftModels/ADL/. The examples include a linear model, a Boltzmann model and a power-law model. To use these models in the calculation of the drift fields, the corresponding configuration file, the temperature and the precision must be given to the function. As an example, in order to use the Boltzmann model at a temperature of 100 K:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_drift_velocity_config_boltzmann.yaml>\", T = T, temperature = 100) \nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no temperature is given as a parameter, the calculations will be performed at a default temperature of 78 K.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"It should be noted that the correct model has not yet been identified, and the parameters inside these configuration files -besides the default ADL ones- are just educated guesses.","category":"page"},{"location":"man/charge_drift/#Custom-Charge-Drift-Model","page":"Charge Drift","title":"Custom Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The user can implement and use his own drift model.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The first step is to define a struct for the model which is a subtype of SolidStateDetectors.AbstractChargeDriftModel:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"using SolidStateDetectors\nusing SolidStateDetectors: SSDFloat, AbstractChargeDriftModel\nusing StaticArrays\n\nstruct CustomChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T} \n    # optional fields to parameterize the model\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The second step is to define two methods (getVe for electrons and getVh for holes), which perform the transformation of an electric field vector, fv::SVector{3,T}, into a velocity vector. Note, that the vectors are in cartesian coordinates, independent of the coordinate system (cartesian or cylindrical) of the simulation. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"function SolidStateDetectors.getVe(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return -fv\nend\n\nfunction SolidStateDetectors.getVh(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return fv\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Then, one can apply the model to the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = CustomChargeDriftModel{T}()\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/man/primitives.jl\"","category":"page"},{"location":"man/primitives/#Volume-Primitives","page":"Primitives","title":"Volume Primitives","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"using SolidStateDetectors\nimport SolidStateDetectors.ConstructiveSolidGeometry as CSG\nusing Plots\nT = Float64;\nnothing #hide","category":"page"},{"location":"man/primitives/#List-of-YAML-example-configuration-files-for-Primitives","page":"Primitives","title":"List of YAML example configuration files for Primitives","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Under SolidStateDetectors.jl/examples/example_primitive_files there are some examples how to define the different primitives via the YAML format:","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"path_to_example_primitives_config_files = joinpath(dirname(dirname(pathof(SolidStateDetectors))), \"examples\", \"example_primitive_files\")\nexample_primitives_config_filenames = readdir(path_to_example_primitives_config_files)\nfor fn in example_primitives_config_filenames\n    println(fn)\nend","category":"page"},{"location":"man/primitives/#Box","page":"Primitives","title":"Box","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Box.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"box = CSG.Geometry(T, cfn)\nplot(box)","category":"page"},{"location":"man/primitives/#Cone:","page":"Primitives","title":"Cone:","text":"","category":"section"},{"location":"man/primitives/#Tube","page":"Primitives","title":"Tube","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone_tube.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/primitives/#VaryingTube","page":"Primitives","title":"VaryingTube","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/primitives/#Ellipsoid","page":"Primitives","title":"Ellipsoid","text":"","category":"section"},{"location":"man/primitives/#Sphere","page":"Primitives","title":"Sphere","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Ellipsoid_full_sphere.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"ellipsoid = CSG.Geometry(T, cfn)\nplot(ellipsoid)","category":"page"},{"location":"man/primitives/#Torus","page":"Primitives","title":"Torus","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Torus.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"torus = CSG.Geometry(T, cfn)\nplot(torus, zlims = [-6,6], camera = (40, 55))","category":"page"},{"location":"man/primitives/#Prism","page":"Primitives","title":"Prism","text":"","category":"section"},{"location":"man/primitives/#Hexagonal-Prism","page":"Primitives","title":"Hexagonal Prism","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"RegularPrism_hexagon.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"prism = CSG.Geometry(T, cfn)\nplot(prism)","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/transformations/#Transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"All Volume Primitives are defined such that they are centered around the origin of the coordinate system. They can be rotated in their local coordinate system and translated to their final position in the global coordinate system.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"There are two possibilities two rotate and translate volume primitives. One is to define the rotation/translation inside the primitive definition. The other one is to define it for complete sets like detectors, unions, etc.","category":"page"},{"location":"man/transformations/#Rotations","page":"Transformations","title":"Rotations","text":"","category":"section"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Rotations are defined in the configuration files by either a 3times3 rotation matrix or a set of angles with respective rotation axes are required.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If a tube is to be rotated 45° around the x axis, the rotation is parsed to the primitive as additional rotation field in the primitive definition.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"In this case, the rotation around the x axis by 45° is parsed in the format seen above: the name of the axis to be rotated around is given as (upper-case) letter, followed by the rotation angle. If no units are given to the rotation angle, it will be parsed with units.angle.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If the rotation is to be described as multiple subsequent rotations, it can be passed using an array of angles with respective axis description as field name, e.g.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    XZ: [45°, 30°]","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"will first rotate the tube 45° around the x axis, followed by a 30° rotation around the z axis.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Alternatively, a full 3times3 matrix can be passed using the M field, e.g.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    M: [1, 0, 0, 0, 0, -1, 0, 1, 0]","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"will transform the primitive using the rotation matrix","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"left beginarrayccc10000-1010endarrayright","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"which corresponds to X: 45°.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Alternative naming for the rotation field can be rotate.","category":"page"},{"location":"man/transformations/#Translations","page":"Transformations","title":"Translations","text":"","category":"section"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Translations are defined in the configuration files through a Cartesian vector.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If a tube is translated 1cm along the x axis, the translation is parsed to the primitive as additional origin field in the primitive definition.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  origin:\n    x: 1cm","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"The Cartesian vector can also be passed as a vector, i.e.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  origin: [1cm, 0, 0]","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If no units are given, the translation is parsed in units of units.length.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Alternative naming for the origin field can be translate and translation.","category":"page"},{"location":"man/transformations/#Combination-of-Transformations","page":"Transformations","title":"Combination of Transformations","text":"","category":"section"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If both a rotation and translation are defined in a primitive definition, it is first rotated and then translated.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°\n  origin: \n    z: 1cm","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"would first rotate the tube by 45° around the x axis before translating it 1cm along the z axis.","category":"page"},{"location":"man/transformations/#Transforming-Sets","page":"Transformations","title":"Transforming Sets","text":"","category":"section"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"If a union of two primitives should be transformed all together, the transformation can also be defined by nesting the union into a translate with respective information, e.g.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"translate: \n  z: 1\n  union:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"Same applies for rotations or other sets, e.g.","category":"page"},{"location":"man/transformations/","page":"Transformations","title":"Transformations","text":"rotate: \n  X: 45°\n  difference:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential is a theoretical potential that describes what fraction of a charge at position vecr is seen by a contact, C_i. The weighting potential can take values between 0, i.e. the charge is not seen by the electrode, and 1, i.e. the charge is collected by the electrode. ","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi_i^w(vecr)right) = 0\r\nPhi_i^w(vecr)vert_C_j = left beginarrayll 1  textif i = j  0  textif i neq j endarray right","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"where Phi_i^w is the electric potential and epsilon_r is the dielectric distribution.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The net charge induced on each electrode C_i, Q_i, by electrons and hole with absolute charge Q is given by the Schockley-Ramo theorem:","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"Q_i = Q left( sumlimits_textholes Phi_i^w(vecr_h) -  sumlimits_textelectrons Phi_i^w(vecr_e) right)","category":"page"},{"location":"man/weighting_potentials/#Simulation-Algorithm","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential when calling calculate_weighting_potential!(simulation, contact_id). The differences are that rho(vecr) is set to zero and that the boundary conditions of fixed values on the contacts are adapted.","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Visualization-/-Plotting-(Optional)","page":"Installation","title":"Visualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Load the Plots.jl package (and optionally the backend pyplot) via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Plots","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The backends supported by SolidStateDetectors.jl are gr and pyplot. By default, gr is loaded when importing Plots.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This documentation was build with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg, Plots # hide\r\npkgversion(m::Module) = Pkg.TOML.parsefile(joinpath(dirname(string(first(methods(m.eval)).file)), \"..\", \"Project.toml\"))[\"version\"] # hide\r\nPlots_version = pkgversion(Plots) # hide\r\nGR_version = pkgversion(GR) # hide\r\nprint(\"Plots: v$(Plots_version) - GR: v$(GR_version)\") # hide","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\n    using SolidStateDetectors.ConstructiveSolidGeometry\r\nend","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SolidStateDetectors, SolidStateDetectors.ConstructiveSolidGeometry]\r\nOrder = [:module, :type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.ADLChargeDriftModel","page":"API","title":"SolidStateDetectors.ADLChargeDriftModel","text":"ADLChargeDriftModel{T <: SSDFloat, M <: AbstractDriftMaterial, N, TM <: AbstractTemperatureModel{T}} <: AbstractChargeDriftModel{T}\n\nFields\n\nelectrons::CarrierParameters{T}\nholes::CarrierParameters{T}\ncrystal_orientation::SMatrix{3,3,T,9}\nγ::SVector{N,SMatrix{3,3,T,9}}\nparameters::ADLParameters{T}\ntemperaturemodel::TM\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractChargeDensity","page":"API","title":"SolidStateDetectors.AbstractChargeDensity","text":"# abstract type AbstractChargeDensity{T <: SSDFloat} end\n\nCharge densities <: AbstractChargeDensity should be defined to return (via get_charge_density-method) a charge density in SI units, thus, in Q/m^3.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractConfig","page":"API","title":"SolidStateDetectors.AbstractConfig","text":"abstract type AbstractConfig{T <: SSDFloat} end\n\nSupertype of all detector/world/object configs.\n\nUser defined geometries must be subtype of AbstractConfig{T}.\n\nThere are a few functions which must be defined for a user config, e.g. struct UserConfig{T} <: AbstractConfig{T}:\n\nFor cylindrical grids:\n\nin(pt::CylindricalPoint{T}, config::UserConfig{T})::Bool where {T <: SSDFloat}\nGrid(config::UserConfig{T})::Grid{T, 3, Cylindrical} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::CylindricalPoint{T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cylindrical}, config::UserConfig{T}; weighting_potential_contact_id::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\nFor cartesian grids:\n\nin(pt::CartesianPoint{3, T}, config::UserConfig{T})::Bool \nGrid(config::UserConfig{T})::Grid{T, 3, Cartesian} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::CartesianPoint{3, T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cartesian}, config::UserConfig{T}; weighting_potential_contact_id::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractImpurityDensity","page":"API","title":"SolidStateDetectors.AbstractImpurityDensity","text":"# abstract type AbstractImpurityDensity{T <: SSDFloat} end\n\nImpurity densities <: AbstractImpurityDensity should be defined to return (via get_impurity_density-method) a density of impurities in SI units, thus, in 1/m^3. For semiconductors, this will be converted internally into a charge distribution by multiplication with the elementary charge.  The sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. \n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantChargeDensity","page":"API","title":"SolidStateDetectors.ConstantChargeDensity","text":"struct ConstantChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nReturns always a fixed charge density.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantImpurityDensity","page":"API","title":"SolidStateDetectors.ConstantImpurityDensity","text":"struct ConstantImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nReturns always a fixed impurity density.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"mutable struct Contact{T} <: AbstractContact{T}\n\nT: Type of precision.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalChargeDensity","page":"API","title":"SolidStateDetectors.CylindricalChargeDensity","text":"struct CylindricalChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each spatial dimension of a cylindrical coordinate system. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in r and z direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalImpurityDensity","page":"API","title":"SolidStateDetectors.CylindricalImpurityDensity","text":"struct CylindricalImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nSimple Impurity density model which assumes a linear gradient in Impurity density in each spatial dimension of a cylindrical coordinate system. offsets::NTuple{3, T} are the Impurity densities at 0 and gradients::NTuple{3, T} are the linear slopes in r and z direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis{T, BL, BR} <: AbstractAxis{T, BL, BR}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nBL: left boundary condition\nBR: right boundary condition\nI: IntervalSets.Interval (closed or open boundaries)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nL, R {:closed, :open} \nticks: Ticks of the axis\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricFieldChargeDriftModel","page":"API","title":"SolidStateDetectors.ElectricFieldChargeDriftModel","text":"ElectricFieldChargeDriftModel <: AbstractChargeDriftModel\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cartesian}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cartesian} ; kwargs...)::ElectricPotential{T, 3, Cartesian}\n\nExtracts the electric potential from setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::ElectricPotential{T, 3, Cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a huge amount of events.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"T: tick type\nN: N dimensional\nS: System (Cartesian, Cylindrical...)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearChargeDensity","page":"API","title":"SolidStateDetectors.LinearChargeDensity","text":"struct LinearChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension, x, y and z.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearImpurityDensity","page":"API","title":"SolidStateDetectors.LinearImpurityDensity","text":"struct LinearImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nSimple Impurity density model which assumes a linear gradient in Impurity density in each dimension of a Cartesian coordinate system. offsets::NTuple{3, T} are the Impurity densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension, x, y and z.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now there are:\n\n`const update_bit      = 0x01`\n`const undepleted_bit  = 0x02`\n`const pn_junction_bit = 0x04`\n\nHow to get information out of a PointType variable pt:\n\npt & update_bit == 0 -> do not update this point (for fixed points)     \npt & update_bit >  0 -> do update this point    \npt & undepleted_bit > 0 -> this point is undepleted\npt & pn_junction_bit > 0 -> this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes{T, N, S} <: AbstractArray{T, N}\n\nPointTypes stores the point type of each grid point.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::PointTypes{T, 3, Cylindrical}\n\nExtracts the point types from setup and extrapolates it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.PotentialSimulationSetup","page":"API","title":"SolidStateDetectors.PotentialSimulationSetup","text":"PotentialSimulationSetup{T, N, S} <: AbstractPotentialSimulationSetup{T, N}\n\nCollection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Simulation","page":"API","title":"SolidStateDetectors.Simulation","text":"mutable struct Simulation{T <: SSDFloat, CS <: AbstractCoordinateSystem} <: AbstractSimulation{T}\n\nCollection of all parts of a Simulation of a Solid State Detector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"mutable struct SolidStateDetector{T <: SSDFloat} <: AbstractConfig{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}","page":"API","title":"SolidStateDetectors.RBArray","text":"RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type, Grid{T, 3, Cartesian, AT} where AT}} where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, 3, Cartesian} )::Array{et, 4} where {T}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors._convert_to_original_potential-Union{Tuple{ATO}, Tuple{AT}, Tuple{CS}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, 3, CS, ATO}, ElectricPotential{T, 3, CS, ATO}, PointTypes{T, 3, CS, ATO}, WeightingPotential{T, 3, CS, ATO}}, Array{T, 3}, Grid{T, 3, CS, AT}}} where {T, CS, AT, ATO}","page":"API","title":"SolidStateDetectors._convert_to_original_potential","text":"_convert_to_original_potential(::Type{P}, data, grid) where {P, T, CS}\n\nBasically the counterpart to _get_closed_potential.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T}, 1}, Vector{T}, SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, PointTypes{T, 3, S, AT} where AT, Grid{T, 3, S, AT} where AT, CartesianPoint{T}, T, Interpolations.Extrapolation{var\"#s145\", 3, ITPT, IT, ET} where {var\"#s145\"<:(StaticArrays.StaticVector{3, T} where T), ITPT, IT, ET}}} where {T<:Union{Float16, Float32, Float64}, S}","page":"API","title":"SolidStateDetectors._drift_charge!","text":"_drift_charge!(...)\n\nBefore calling this function one should check that startpos is inside det: in(startpos, det)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors._get_closed_potential-Union{Tuple{Union{EffectiveChargeDensity{T, 3, CS, AT}, ElectricPotential{T, 3, CS, AT}, PointTypes{T, 3, CS, AT}, WeightingPotential{T, 3, CS, AT}} where AT}, Tuple{CS}, Tuple{T}} where {T, CS}","page":"API","title":"SolidStateDetectors._get_closed_potential","text":"_get_closed_potential(p::ScalarPotential{T,3,CS}) where {T, CS}\n\nReturns an closed Grid & Potential: E.g. if one of the axis is {:closed,:open} it will turn this into {:closed,:closed} and also extend the data field of the potential in the respective dimension and fill it with the respective values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdd Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state of the electric potential calculation. It overwrites sim.electric_potential, sim.q_eff_imp, sim.q_eff_fix, sim.ϵ and sim.point_types.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state of the weighting potential calculation for the contact with the id contact_id. It overwrites sim.weighting_potentials[contact_id].\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_capacitance","text":"calculate_capacitance(sim::Simulation{T})::T where {T <: SSDFloat}\n\nCalculates the capacitance of an detector in Farad.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_field!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Vararg{Any, N} where N}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.calculate_electric_field!","text":"calculate_electric_field!(sim::Simulation{T}, args...; n_points_in_φ::Union{Missing, Int} = missing, kwargs...)::Nothing\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_potential!","text":"calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing\n\nCompute the electric potential for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are several <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_weighting_potential!","text":"calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing\n\nCompute the weighting potential for the contact with id contact_id for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are several <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical, AT} where AT}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(pts::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_electron_drift_field","text":"get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_hole_drift_field","text":"get_hole_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the hole field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to example detector config files provided by the package.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64, Val{true}, Val{true}}","page":"API","title":"SolidStateDetectors.get_rbidx_right_neighbour","text":"get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nneeds docu...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cartesian, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cartesian},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            )::Nothing where {T, even_points, depletion_handling_enabled}\n\n(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cylindrical, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cylindrical},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                        )::Nothing where {T, even_points, depletion_handling_enabled}\n\n(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.nidx-Tuple{Int64, Val{true}, Val{true}}","page":"API","title":"SolidStateDetectors.nidx","text":"nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nfirst type argument:  type of the orgal point (for even points -> Val{true}(), else Val{false}()) second type argument: is sum of other point indices even or odd -> (if sum is even -> Val{true}(), else Val{false}())\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"parse_config_file(filename::AbstractString)::SolidStateDetector{T} where {T <: SSDFloat}\n\nReads in a config file and returns an Detector struct which holds all information specified in the config file. Currently supported formats for the config file: .json, .yaml\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, Grid{T, 3, S, AT} where {S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}, CartesianPoint{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.point_type","text":"For charge drift...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.readsiggen-Tuple{String}","page":"API","title":"SolidStateDetectors.readsiggen","text":"readsiggen(file_path::String[, T::Type=Float64])\n\nRead the '*.config' file in 'file_path' for SigGen and returns a dictionary of all parameters. Non-existing parameteres are set to 0. ...\n\nArguments\n\nfile_path::String: file path for the SigGen config file.\nT::Type=Float64: type of the parameters in the output dictionary.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.electric_potential and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.weighting_potentials[contact_id] and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine_scalar_potential-Union{Tuple{only_2d}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, N, S, AT}, ElectricPotential{T, N, S, AT}, PointTypes{T, N, S, AT}, WeightingPotential{T, N, S, AT}} where {N, S, AT}, Tuple{T, T, T}, Tuple{T, T, T}}} where {T, only_2d}","page":"API","title":"SolidStateDetectors.refine_scalar_potential","text":"refine_scalar_potential(p::ScalarPotential{T}, max_diffs::NTuple{3, T}, minimum_distances::NTuple{3, T}; \n    only2d::Val{only_2d} = Val(size(p.data, 2)==1)) where {T, only_2d}\n\nRefine any scalar potential p. \n\nExtent the grid to be a closed grid in all dimensions. \nRefine the axis of the grid based on max_diffs and minimum_applied_potential: Insert N new ticks between to existing ticks such that the potential difference between each tick becomes smaller than max_diff[i] (i -> dimension) but that the distances between the ticks stays larger than minimum_distances[i].\nCreate the new data array for the refined grid and fill it by interpolation of the the initial (coarse) grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.siggentodict-Tuple{Dict}","page":"API","title":"SolidStateDetectors.siggentodict","text":"siggentodict(config::Dict[, units::Dict, detector_name::String])\n\nConverts the dictionary containing the parameters from a SigGen config file to a SSD config dictionary. This dictionary can be saved as a JSON file using the JSON package and 'JSON.print(file, config, 4)'. The 'detector_name' is set to \"Public Inverted Coax\" by default to inherit the colour scheme. ...\n\nArguments\n\nconfig::Dict: dictionary containing SigGen parameters (output of readsiggen()).\nunits::Dict: units used in SigGen file (set to 'mm', 'deg', 'V' and 'K').\ndetector_name::String: name of the detector.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"function simulate!( sim::Simulation{T};  \n                refinement_limits = [0.2, 0.1, 0.05],\n                min_tick_distance::Union{Missing, length_unit, Tuple{length_unit, angle_unit, length_unit}} = missing,\n                max_tick_distance::Union{Missing, length_unit, Tuple{length_unit, angle_unit, length_unit}} = missing,\n                max_distance_ratio::Real = 5,\n                verbose::Bool = false,\n                use_nthreads::Int = Base.Threads.nthreads(),\n                sor_consts::Union{Missing, <:Real, Tuple{<:Real,<:Real}} = missing,\n                max_n_iterations::Int = -1,\n                depletion_handling::Bool = false, \n                convergence_limit::Real = 1e-7 ) where {T <: SSDFloat}\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is -1. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, S, TGW, AT} where {TGW, AT}, Int64, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, S, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.update!","text":"update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing\n\nLoop over even grid points. A point is even if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -> rbpotential[ inds..., rbi ]).\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.electric_potential and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.weighting_potentials[contact_id] and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry","text":"module ConstructiveSolidGeometry\n\n\n\n\n\n","category":"module"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Box","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Box","text":"Box{T, CO} <: AbstractVolumePrimitive{T}\n\nT: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive <-> whether surface belongs to it or not\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","text":"struct CSGDifference{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na && !b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","text":"struct CSGIntersection{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na && b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","text":"struct CSGUnion{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na || b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","text":"struct CartesianPoint{T} <: AbstractCoordinatePoint{T, Cartesian}\n\nx: x-coordinate in meter\ny: y-coordinate in meter\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","text":"struct CartesianVector{T} <: AbstractCoordinateVector{T, Cartesian}\n\nx: x-component in meter\ny: y-component in meter\nz: z-component in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Cone","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Cone","text":"struct Cone{T,CO,TR,TP} <: AbstractVolumePrimitive{T, CO}\n\nT: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive <-> whether surface belongs to it or not\n\nr::TR: \nTR = Real -> Cylinder\nTR = (Real, Real) -> Tube (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) Solid widening Cylinder  -> (rbot = r[1][1], rtop = r[1][2])\nTR = ((Real,Real), (Real,Real)) Solid widening Tube ->\n\n(rbotin = r[1][1], rbotout = r[1][2], rtopin = r[2][1], rtopout = r[2][2])     * TR = (Nothing, (Real,Real)) Cone -> (rbotin = rbotout = 0, rtopin = r[2][1], rtopout = r[2][2])     * TR = ((Real,Real), Nothing) Cone -> (rbotin = r[1][1], rbotout = r[1][2], rtopin = rtopout = 0)     * ... (+ elliptical cases -> (a, b))     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\nhZ::T: half height/length of the cone\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","text":"struct ConeMantle{T,TR,TP,D} <: AbstractSurfacePrimitive{T}\n\nT: Type of values, e.g. Float64\n\nr::TR: \nTR = Real -> Cylinder Mantle (a = b = r)\nTR = (Real, Real) -> Cone Mantle (rbot = r[1], rtop = r[2]) \nTR = ((Real,), (Real,)) -> Elliptical Cylinder Mantle (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Cone Mantle \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\nhZ::T: half hight/length of the cone mantle\nD: :inwards or :outwards: Whethe the normal points inside or outside\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","text":"struct CylindricalPoint{T} <: AbstractCoordinatePoint{T, Cylindrical}\n\nr: Radius in meter\nφ: Polar angle in radians. φ == 0 <=> Parallel to x-axis of cartesian coordinate system.\"\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","text":"struct CylindricalVector{T} <: AbstractCoordinateVector{T, Cylindrical}\n\nr: Radius in meter\nφ: Polar angle in radians. φ == 0 <=> Parallel to x-axis of cartesian coordinate system.\"\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Ellipse","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Ellipse","text":"struct Ellipse{T,TR} <: AbstractLinePrimitive{T}\n\nr::TR: \nTR = Real -> Circle (a = b = r)\nTR = (Real, Real) -> Circular Annulus (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) -> Ellipse (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Annulus \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","text":"EllipticalSurface{T,TR,TP} <: AbstractSurfacePrimitive{T}\n\nr::TR: \nTR = Real -> Full Circle (a = b = r)\nTR = (Real, Real) -> Circular Annulus (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) -> Full Ellipse (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Annulus \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.extreme_points","text":"extreme_points(es::AbstractPrimitive{T}) where {T}\n\nGeneral implementation for all primitives.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::EllipsoidMantle{T,T}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::EllipsoidMantle{T,NTuple{3,T}}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(tm::TorusMantle{T}, l::Line{T}) where {T}\n\nThe function will always return 4 CartesianPoint's. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN's as there coordinates.\n\nSolve: solve (sqrt((L1 + λ*D1)^2 + (L2 + λ*D2)^2)-R)^2 + (L3 + λ*D3)^2 = r^2 for λ\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial-Union{Tuple{T}, NTuple{4, T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial","text":"roots_of_4th_order_polynomial(a::T, b::T, c::T, d::T, e::T)\n\nCalculate the 4 (possible) roots of x^4 + ax^3 + bx^2 + cx + d = 0\n\n\n\n\n\n","category":"method"},{"location":"man/electric_field/#Electric-Field","page":"Electric Field","title":"Electric Field","text":"","category":"section"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The electric field is calculated from the electric potential for each grid point (ijk) when calling calculate_electric_field!(simulation). The field vector components on each grid point are the means of the electric field in each direction calculated as finite differences.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a Cartesian grid, this results in:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_x^ijk mathcalE_y^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_x^ijk = dfrac12left( dfracPhi_i+1jk-Phi_i+1jkx_i+1 - x_i + dfracPhi_ijk-Phi_i-1jkx_i - x_i-1 right)hspace10pt\n\tmathcalE_y^ijk = dfrac12left( dfracPhi_ij+1k-Phi_ijky_j+1 - y_j + dfracPhi_ijk-Phi_ij-1ky_j - y_j-1 right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a cylindrical grid, the calculation is:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_r^ijk mathcalE_varphi^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_r^ijk = dfrac12left(dfracPhi_i+1jk-Phi_ijkr_i+1 - r_i + dfracPhi_ijk-Phi_i-1jkr_i - r_i-1right)hspace10pt\n\tmathcalE_varphi^ijk = dfrac12 r_ileft(dfracPhi_ij+1k-Phi_ijkvarphi_j+1 - varphi_j + dfracPhi_ijk-Phi_ij-1kvarphi_j - varphi_j-1right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"This discrete electric field is interpolated (via Interpolations.jl)  during the drift in order to get the electric field at the current position of the charge carrier.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The calculated electric field is stored as a field in the Simulation object, i.e. simulation.electric_field, consisting of the actual field vectors for each grid point stored in simulation.electric_field.data and the corresponding grid in simulation.electric_field.grid. ","category":"page"},{"location":"man/electric_field/#Visualization","page":"Electric Field","title":"Visualization","text":"","category":"section"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The electric field can be plotted using the Plots.jl package. The electric field strength is plotted using plot(simulation.electric_field), whereas the electric field lines can be plotted on top of that using  plot_electric_fieldlines!(simulation).","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"Minimum working example:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"using SolidStateDetectors\nusing Plots\nsimulation = Simulation(SSD_examples[:InvertedCoax])\ncalculate_electric_potential!(simulation)\ncalculate_electric_field!(simulation)\nplot(simulation.electric_field, full_det = true)\nplot_electric_fieldlines!(simulation, full_det = true)","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#SolidStateDetectors.jl","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/primitives.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/transformations.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_potential.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_field.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/charge_drift.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"#Citing-SolidStateDetectors.jl","page":"Home","title":"Citing SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using SolidStateDetectors.jl for research, teaching or similar, please cite the paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Abt:2021SSD,\r\n  author        = {Abt, I. and Fischer, F. and Hagemann, F. and Hauertmann, L. and Schulz, O. and Schuster, M. and Zsigmond, A. J.},\r\n  title         = {Simulation of semiconductor detectors in 3D with SolidStateDetectors.jl},\r\n  year          = {2021},\r\n  month         = {3},\r\n  journal       = {Journal of Instrumentation},\r\n  pubstate      = {Accepted},\r\n  eprint        = {2104.00109},\r\n  archiveprefix = {ArXiv},\r\n  primaryclass  = {physics.ins-det},\r\n}","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Example-1:-Inverted-Coax-Detector","page":"Tutorial","title":"Example 1: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsimulation = Simulation{T}(SSD_examples[:InvertedCoax])\n\nplot(simulation.detector)\nsavefig(\"tutorial_det.pdf\") # hide\nsavefig(\"tutorial_det.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_det)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"apply_initial_state!(simulation, ElectricPotential) # optional\nplot(\n    plot(simulation.electric_potential), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.q_eff_imp), # charge density distribution\n    plot(simulation.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_initial_condition.pdf\") # hide\nsavefig(\"tutorial_initial_condition.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_initial_condition)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, calculate the electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_potential!( simulation,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01])\n\nplot(\n    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.q_eff_imp), # charge density distribution\n    plot(simulation.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_calculated_potential.pdf\") # hide\nsavefig(\"tutorial_calculated_potential.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"tutorial/#Partially-depleted-detectors","page":"Tutorial","title":"Partially depleted detectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulation_undep = deepcopy(simulation)\nsimulation_undep.detector = SolidStateDetector(simulation_undep.detector, contact_id = 2, contact_potential = 500); # V  <-- Bias Voltage of Mantle\n\ncalculate_electric_potential!( simulation_undep,\n                               depletion_handling = true,\n                               convergence_limit=1e-6,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01],\n                               verbose = false)\n\n\nplot(\n    plot(simulation_undep.electric_potential),\n    plot(simulation_undep.point_types),\n    layout = (1, 2), size = (800, 700)\n)\nsavefig(\"tutorial_calculated_potential_undep.pdf\") # hide\nsavefig(\"tutorial_calculated_potential_undep.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential_undep)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare both volumes:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Depleted:   \", get_active_volume(simulation.point_types))\nprintln(\"Undepleted: \", get_active_volume(simulation_undep.point_types));\nnothing #hide","category":"page"},{"location":"tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_field!(simulation, n_points_in_φ = 72)\n\nplot(simulation.electric_field, full_det = true, φ = 0.0, size = (500, 500))\nplot_electric_fieldlines!(simulation, full_det = true, φ = 0.0)\nsavefig(\"tutorial_electric_field.pdf\") # hide\nsavefig(\"tutorial_electric_field.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_electric_field)","category":"page"},{"location":"tutorial/#Drift-field-calculation","page":"Tutorial","title":"Drift field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the Bruyneel model from the Agata Data Library (ADL) is used. Other configurations are saved in their configuration files and can be found under:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<package_directory>/examples/example_config_files/ADLChargeDriftModel/<config_filename>.yaml.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set the charge drift model of the simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"charge_drift_model = ADLChargeDriftModel()\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And apply the charge drift model to the electric field:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_drift_fields!(simulation)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's create an \"random\" (multiside) event:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevent = Event(starting_positions, energy_depos);\n\ntime_step = 5u\"ns\"\ndrift_charges!(event, simulation, Δt = time_step)\n\nplot(simulation.detector, size = (700, 700))\nplot!(event.drift_paths)\nsavefig(\"tutorial_drift_paths.pdf\") # hide\nsavefig(\"tutorial_drift_paths.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_drift_paths)","category":"page"},{"location":"tutorial/#Weighting-potential-calculation","page":"Tutorial","title":"Weighting potential calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for contact in simulation.detector.contacts\n    calculate_weighting_potential!(simulation, contact.id, refinement_limits = [0.2, 0.1, 0.05, 0.01], n_points_in_φ = 2, verbose = false)\nend\n\nplot(\n    plot(simulation.weighting_potentials[1]),\n    plot(simulation.weighting_potentials[2]),\n    size = (900, 700)\n)\nsavefig(\"tutorial_weighting_potentials.pdf\") # hide\nsavefig(\"tutorial_weighting_potentials.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_weighting_potentials)","category":"page"},{"location":"tutorial/#Detector-waveform-generation","page":"Tutorial","title":"Detector waveform generation","text":"","category":"section"},{"location":"tutorial/#Single-event-simulation","page":"Tutorial","title":"Single-event simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulate!(event, simulation) # drift_charges + signal generation of all channels\n\np_pc_signal = plot( event.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = \"Time / ns\",\n                    legend = false, tickfontsize = 12, ylabel = \"Energy / eV\", guidefontsize = 14)\nsavefig(\"tutorial_waveforms.pdf\") # hide\nsavefig(\"tutorial_waveforms.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_waveforms)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/electric_potential/#Electric-Potential","page":"Electric Potential","title":"Electric Potential","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is given by Gauss' law in matter","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = - dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potential/#Simulation-Algorithm","page":"Electric Potential","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is calculated through successive over relaxation when calling calculate_electric_potential!(simulation). The equation is numerically solved on a three-dimensional adaptive red/black grid. The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical. To use multiple threads for the simulation, the environment variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"At the beginning of the simulation, each grid point, (ijk) is assigned its dielectric constant, epsilon_r(vecr_ijk), as well as its effective charge, Q_texteff = rho(vecr_ijk) cdot V_ijk epsilon_0, where V_ijk is the volume assigned to the grid point (ijk).","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"These quantities are stored in the fields simulation.q_eff_imp and simulation.ϵ_r and can be plotted using","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors\r\nusing Plots \r\nsimulation = Simulation(SSD_examples[:InvertedCoax])\r\napply_initial_state!(simulation, ElectricPotential)\r\nplot(\r\n  plot(simulation.q_eff_imp),\r\n  plot(simulation.ϵ_r)\r\n)","category":"page"},{"location":"man/electric_potential/#Impurity-Densities","page":"Electric Potential","title":"Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"One contribution to the charge density rho(vecr) is the impurity density of the semiconductor of a detector. Some simple impurity density profiles are already implemented in SolidStateDetectors.jl and can be easily accessed in the configuration files. Note that all impurity densities are given in units of atoms / particles per volume.","category":"page"},{"location":"man/electric_potential/#Constant-Impurity-Density","page":"Electric Potential","title":"Constant Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"A constant impurity density throughout the detector volume can be modeled with ConstantImpurityDensity. In the configuration files, constant impurity densities are defined with the value of the constant impurity density, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: constant\r\n  value: 1e10cm^-3 # => 10¹⁹ m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"If no units are given, value is interpreted in units of units.length^-3. They are converted is SI units (m^(-3)) internally.","category":"page"},{"location":"man/electric_potential/#Linear-Impurity-Density","page":"Electric Potential","title":"Linear Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a linear gradient can be modeled with LinearImpurityDensity. In the configuration files, linear impurity densities are defined with an init (initial) value and gradient along each Cartesian direction (x, y and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  z:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"or","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  x:\r\n    init: 0\r\n    gradient: 1e10\r\n  z:\r\n    init: 0\r\n    gradient: 1e10","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"In the first example, the init value corresponds to the value at z = 0 whereas the gradient points towards positive z. In the second example, the impurity density is 0 at the origin of the coordinate system, whereas the gradient of the impurity density profile points in langle101rangle direction. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Cylindrical-Impurity-Density","page":"Electric Potential","title":"Cylindrical Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a radial gradient can be modeled with CylindricalImpurityDensity. In the configuration files, cylindrical impurity densities are defined with an init (initial) value and gradient along each cylindrical spatial direction (r and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: cylindrical\r\n  r:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Here, the impurity density at the origin is 10^10cm^-3 and it increases radially with the gradient 10^10cm^-4. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Custom-Impurity-Density","page":"Electric Potential","title":"Custom Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The source code for the previously introduced impurity densities can be found here. More complex impurity density profiles can be defined by the user. Each custom impurity density is a new struct and subtype of SolidStateDetectors.AbstractImpurityDensity and needs a method SolidStateDetectors.get_impurity_density that returns the impurity density at a given point pt.","category":"page"},{"location":"man/electric_potential/#Example-1:-Radially-Oscillating-Impurity-Density","page":"Electric Potential","title":"Example 1: Radially Oscillating Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractChargeDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct OscillatingImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    wavelength::T \r\n    amplitude::T\r\n    offset::T\r\nend\r\n\r\n# add get_charge_density for the newly defined charge density model\r\nfunction SolidStateDetectors.get_impurity_density(tcdm::TranslatedChargeDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    cyl_pt = CylindricalPoint(pt) # convert point to a CylindricalPoint\r\n    return offset + amplitude * sin(2π * cyl_pt.r / wavelength)\r\nend","category":"page"},{"location":"man/electric_potential/#Example-2:-Translating-Existing-Impurity-Densities","page":"Electric Potential","title":"Example 2: Translating Existing Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractImpurityDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct TranslatedImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    charge_density_model::AbstractImpurityDensity{T}\r\n    translate::CartesianVector{T}\r\nend\r\n\r\n# add get_impurity_density for the newly defined impurity density model\r\nfunction SolidStateDetectors.get_impurity_density(tcdm::TranslatedImpurityDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    translated_pt::CartesianPoint{T} = CartesianPoint(pt) - tcdm.translate\r\n    return get_impurity_density(tcdm.charge_density_model, translated_pt)\r\nend","category":"page"},{"location":"man/electric_potential/#Charge-Densities","page":"Electric Potential","title":"Charge Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Another contribution to the charge density rho(vecr) can be charged surfaces or volumes that can be modeled using passive objects. The same profiles as for impurity densities are defined here that can be accessed similarly, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"charge_density:\r\n  name: constant\r\n  value: 1e-10 # => 10⁻¹⁰ C/m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Note that, in contrast to impurity densities, charge densities are given in units of the elementary charge per volume.","category":"page"}]
}
