var documenterSearchIndex = {"docs":
[{"location":"man/config_files/#Configuration-Files","page":"Configuration Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detector, its surroundings and symmetries can be specified in configuration files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"SolidStateDetectors.jl supports YAML and JSON as formats for the configuration files.","category":"page"},{"location":"man/config_files/#Example-Configuration-Files","page":"Configuration Files","title":"Example Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Several example configuration files can be found under","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"<package_directory>/examples/example_config_files/.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They are accessible through a dictionary, SSD_examples, defined in the package:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"using SolidStateDetectors\r\nkeys(SSD_examples) # dictionary holding the full path to the corresponding configuration files","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They can be loaded via","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"path_to_config_file = SSD_examples[:InvertedCoax]\r\nsim = Simulation(path_to_config_file)","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)","page":"CSG","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"All objects are defined through Constructive Solid Geometry (CSG), where complex geometries can be build by combining simple volume primitives (e.g. Box) through boolean operators. ","category":"page"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"The primitives which can be used are shown under Volume Primitives together with how they can be specified in the configuration files.","category":"page"},{"location":"man/csg/#Boolean-operators","page":"CSG","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"The boolean operators are union, difference and intersection:","category":"page"},{"location":"man/csg/#Union","page":"CSG","title":"Union","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"geometry:\n  type: union # A || B\n  parts:\n    - tube: # A\n        r: 0.5\n        h: 1\n        origin: \n          z: 1\n    - tube: # B\n        r: 1\n        h: 1","category":"page"},{"location":"man/csg/#Difference","page":"CSG","title":"Difference","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"geometry: # A && !B\n  type: difference\n  parts:\n    - tube: # A\n        r: 0.5\n        h: 1.2\n    - tube: # B\n        r: 1\n        h: 1","category":"page"},{"location":"man/csg/#Intersection","page":"CSG","title":"Intersection","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"geometry: # A && B\n  type: intersection\n  parts:\n    - tube: # A\n        r: \n          from: 0.5\n          to: 1\n        h: 1\n    - tube: # B\n        r: 1\n        h: 1","category":"page"},{"location":"man/IO/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"ToDo...","category":"page"},{"location":"man/electric_potentials/#Electric-Potentials","page":"Electric Potentials","title":"Electric Potentials","text":"","category":"section"},{"location":"man/electric_potentials/#Simulation-Algorithm","page":"Electric Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The electric potential is calculated through successive over relaxation (SOR).","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The calculation is based on Gauss' law in matter","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = - dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The equation is numerically solved on a 3-dimensional adaptive red/black grid.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"Cylindrical and cartesian coordinates are supported.","category":"page"},{"location":"man/electric_potentials/#Multithreading","page":"Electric Potentials","title":"Multithreading","text":"","category":"section"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"To use multiple threads for the simulation, the environement variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/man/primitives.jl\"","category":"page"},{"location":"man/primitives/#Volume-Primitives","page":"Primitives","title":"Volume Primitives","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"using SolidStateDetectors\nimport SolidStateDetectors.ConstructiveSolidGeometry as CSG\nusing SolidStateDetectors.ConstructiveSolidGeometry: ClosedPrimitive\nusing SolidStateDetectors.ConstructiveSolidGeometry: Box\nusing Plots; gr()\nPlots.reset_defaults()\nT = Float64;\nnothing #hide","category":"page"},{"location":"man/primitives/#List-of-YAML-example-configuration-files-for-Primitives","page":"Primitives","title":"List of YAML example configuration files for Primitives","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Under SolidStateDetectors.jl/examples/example_primitive_files there are some examples how to define the different primitives via the YAML format:","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"path_to_example_primitives_config_files = joinpath(dirname(dirname(pathof(SolidStateDetectors))), \"examples\", \"example_primitive_files\")\nexample_primitives_config_filenames = readdir(path_to_example_primitives_config_files)\nfor fn in example_primitives_config_filenames\n    println(fn)\nend","category":"page"},{"location":"man/primitives/#Box","page":"Primitives","title":"Box","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Box.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"box = CSG.Geometry(T, cfn)\nplot(box)","category":"page"},{"location":"man/primitives/#Cone:","page":"Primitives","title":"Cone:","text":"","category":"section"},{"location":"man/primitives/#Tube","page":"Primitives","title":"Tube","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone_tube.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/primitives/#VaryingTube","page":"Primitives","title":"VaryingTube","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/primitives/#Ellipsoid","page":"Primitives","title":"Ellipsoid","text":"","category":"section"},{"location":"man/primitives/#Sphere","page":"Primitives","title":"Sphere","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Ellipsoid_full_sphere.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"ellipsoid = CSG.Geometry(T, cfn)\nplot(ellipsoid)","category":"page"},{"location":"man/primitives/#Torus","page":"Primitives","title":"Torus","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Torus.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"torus = CSG.Geometry(T, cfn)\nplot(torus, zlims = [-6,6], camera = (40, 55))","category":"page"},{"location":"man/primitives/#Prism","page":"Primitives","title":"Prism","text":"","category":"section"},{"location":"man/primitives/#Hexagonal-Prism","page":"Primitives","title":"Hexagonal Prism","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"cfn = joinpath(path_to_example_primitives_config_files, \"RegularPrism_hexagon.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"prism = CSG.Geometry(T, cfn)\nplot(prism)","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/#Simulation-Algorithm","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The only difference is that the charge carrier density ρ(vecr) is set to 0 and all electrodes are fixed to 0 but the one electrode which is fixed to 1.","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Visualization-/-Plotting-(Optional)","page":"Installation","title":"Visualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Load the Plots.jl package (and optionally the backend pyplot) via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Plots","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The backends supported by SolidStateDetectors.jl are gr and pyplot. By default, gr is loaded when importing Plots.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This documentation was build with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg, Plots # hide\r\npkgversion(m::Module) = Pkg.TOML.parsefile(joinpath(dirname(string(first(methods(m.eval)).file)), \"..\", \"Project.toml\"))[\"version\"] # hide\r\nPlots_version = pkgversion(Plots) # hide\r\nGR_version = pkgversion(GR) # hide\r\nprint(\"Plots: v$(Plots_version) - GR: v$(GR_version)\") # hide","category":"page"},{"location":"man/drift_fields/#Drift-Fields","page":"Drift Fields","title":"Drift Fields","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Charged particles in vacuum move along the electric field lines under Coulomb's force, bmF = q bmE, where bmF corresponds to the force experienced by the particle, q is the charge of the particle and bmE is the electric field. Charged particles in vacuum would be continuously accelerated until approaching the speed of light (called ballistic transport), however, inside a material, scattering prevents this constant acceleration and leads to a constant drift velocity ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_d = mu E","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"where v_d is the drift velocity, mu the mobility and E the electric field strength.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The scattering with matter not only limits the absolute drift velocity, it might also deviate the trajectories from the electric field lines: e.g., in crystals, the principal axes orientation has an impact on the resulting drift trajectory. The influence of the scattering on the drift trajectories can be expressed by a 3x3 tensor, the so-called mobility tensor mu_ij, which transforms the electric field, E, into the drift field, v_i:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_i =  mu_ij cdot E_j","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The mobility varies for different materials and depends also on other parameters such as temperature, impurity density and the electric field strength, as explained later.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Electrons and holes have different mobilities, resulting in different drift fields. There are several models for the mobility tensor of electrons and holes in certain materials. Right now, two models are implemented. The first one is a pseudo-drift model, the ElectricFieldChargeDriftModel, which just takes the electric field vectors as drift vectors, see section Electric Field Charge Drift Model. The second one, ADLChargeDriftModel, is a drift model for high purity germanium, see section ADL Charge Drift Model. However, the implementation of an own model is possible and explained in section Custom Charge Drift Model.","category":"page"},{"location":"man/drift_fields/#Electric-Field-Charge-Drift-Model","page":"Drift Fields","title":"Electric Field Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The ElectricFieldChargeDriftModel describes a system in which electrons and holes move along the electric field lines. In this case, the mobility is a scalar pm 1 m²/(Vs) (+ for holes, and - for electrons), and thus, the velocity field has the same (or opposite) direction as the electric field. Even though this model does not describe reality, it is useful in some cases to use the electric field vectors as velocity vectors.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In order to set the ElectricFieldChargeDriftModel for the simulation, the precision type of the calculation T (Float32 or Float64) has to be given as an argument. Note that T has to be of the same precision type of the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ElectricFieldChargeDriftModel(T)\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/#ADL-Charge-Drift-Model","page":"Drift Fields","title":"ADL Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In high-purity germanium, the mobility cannot be expressed by a simple scalar quantity. Germanium has a cubic diamond lattice structure with langle100rangle, langle110rangle and langle111rangle as principal directions. Along these axes, the charge drift is parallel to the electric field. However, the longitudinal drift velocity, v_l, is not equally fast on the three axes. ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"On each axes, v_l can be described through the parametrization proposed by D.M. Caughey and R.E. Thomas, which was later expanded by L. Mihailescu et al.:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The parameters mu_0, E_0 and beta differ for electrons and holes, and mu_n is only relevant for electrons. These parameters were obtained by B. Bruyneel et al. by measuring the drift velocities of electrons and holes in the langle100rangle and langle111rangle directions in high purity germanium at a temperature of 78 K. These parameters are stored in a configuration file, \"drift_velocity_config.yaml\", located in <package_directory>/example/example_config_files/ADLChargeDriftModel. The configuration file is expressed as following:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"model: ADLChargeDriftModel\nphi110: -0.785398\nmaterial: HPGe\ndrift:\n  velocity:\n    model: Bruyneel2006\n    parameters:\n      e100:\n        mu0: 3.8609\n        beta: 0.805\n        E0: 51100\n        mun: -0.0171\n      e111:\n        mu0: 3.8536\n        beta: 0.641\n        E0: 53800\n        mun: 0.051\n      h100:\n        mu0: 6.1824\n        beta: 0.942\n        E0: 18500\n      h111:\n        mu0: 6.1215\n        beta: 0.662\n        E0: 18200","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"where the parameters are stored under the keys e100, e111, h100 and h111, in which e and h stand for electrons and holes, respectively, and 100 and 111, for the principal axes langle100rangle and langle111rangle.  By default, in SolidStateDetectors.jl the langle001rangle axis is aligned with the Z-axis of the coordinate system of the simulation. The crystal orientation can be set through the phi110 parameter, where the langle001rangle axis is still aligned with the Z-axis and the angle between the langle110rangle principal direction of the crystal and the X-axis is given by phi110. Alternatively, the crystal orientation can be set by passing a rotation matrix that describes the rotation from the global coordinate system to the crystal orientation system.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"If the electric field is not aligned with any of the crystal axes, the charge drift velocity is not necessarily aligned with the electric field. In the ADLChargeDriftModel, two models are implemented to describe the charge drift of electrons and holes between the axes. Detailed information about the charge drift models is provided in the papers from L. Mihailescu et al.  for electrons and from B.Bruyneel et al. for holes.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In order to perform the calculation of the drift fields, a configuration file containing the parametrization values like the \"drift_velocity_config.yaml\" (with Bruyneel's data or modified values), has to be passed as an argument to the ADLChargeDriftModel function. The precision of the the calculation T (Float32 or Float64) has to be given as a keyword T. Note that T has to be of the same type as the chosen in the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_ADL_configuration_file>\", T=T)\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The values from the default configuration file correspond to germanium at 78 K. Calculations of the drift field at other temperatures are also supported by the ADLChargeDriftModel. While experimental observations suggest that the charge mobilities of electrons and holes in the crystal are temperature dependent, the dependency law has not yet been established. Several models have been proposed to reproduce the experimental behavior, and some examples of them can be found in the directory <package_directory>/src/ChargeDriftModels/ADL/. The examples include a linear model, a Boltzmann model and a power-law model. To use these models in the calculation of the drift fields, the corresponding configuration file, the temperature and the precision must be given to the function. As an example, in order to use the Boltzmann model at a temperature of 100 K:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_drift_velocity_config_boltzmann.yaml>\", T = T, temperature = 100) \nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"If no temperature is given as a parameter, the calculations will be performed at a default temperature of 78 K.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"It should be noted that the correct model has not yet been identified, and the parameters inside these configuration files -besides the default ADL ones- are just educated guesses.","category":"page"},{"location":"man/drift_fields/#Custom-Charge-Drift-Model","page":"Drift Fields","title":"Custom Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The user can implement and use his own drift model.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The first step is to define a struct for the model which is a subtype of SolidStateDetectors.AbstractChargeDriftModel:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"using SolidStateDetectors\nusing SolidStateDetectors: SSDFloat, AbstractChargeDriftModel\nusing StaticArrays\n\nstruct CustomChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T} \n    # optional fields to parameterize the model\nend","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The second step is to define two methods (getVe for electrons and getVh for holes), which perform the transformation of an electric field vector, fv::SVector{3,T}, into a velocity vector. Note, that the vectors are in cartesian coordinates, independent of the coordinate system (cartesian or cylindrical) of the simulation. ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"function SolidStateDetectors.getVe(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return -fv\nend\n\nfunction SolidStateDetectors.getVh(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return fv\nend","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Then, one can apply the model to the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = CustomChargeDriftModel{T}()\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\n    using SolidStateDetectors.ConstructiveSolidGeometry\r\nend","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SolidStateDetectors, SolidStateDetectors.ConstructiveSolidGeometry]\r\nOrder = [:module, :type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.ADLChargeDriftModel","page":"API","title":"SolidStateDetectors.ADLChargeDriftModel","text":"ADLChargeDriftModel{T <: SSDFloat, M <: AbstractDriftMaterial, N, TM <: AbstractTemperatureModel{T}} <: AbstractChargeDriftModel{T}\n\nFields\n\nelectrons::CarrierParameters{T}\nholes::CarrierParameters{T}\ncrystal_orientation::SMatrix{3,3,T,9}\nγ::SVector{N,SMatrix{3,3,T,9}}\nparameters::ADLParameters{T}\ntemperaturemodel::TM\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractChargeDensity","page":"API","title":"SolidStateDetectors.AbstractChargeDensity","text":"# abstract type AbstractChargeDensity{T <: SSDFloat} end\n\nCharge densities <: AbstractChargeDensity should be defined to return (via get_charge_density-method) a charge density in SI units, thus, in Q/m^3.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractConfig","page":"API","title":"SolidStateDetectors.AbstractConfig","text":"abstract type AbstractConfig{T <: SSDFloat} end\n\nSupertype of all detector/world/object configs.\n\nUser defined geometries must be subtype of AbstractConfig{T}.\n\nThere are a few functions which must be defined for a user config, e.g. struct UserConfig{T} <: AbstractConfig{T}:\n\nFor cylindrical grids:\n\nin(pt::CylindricalPoint{T}, config::UserConfig{T})::Bool where {T <: SSDFloat}\nGrid(config::UserConfig{T})::Grid{T, 3, Cylindrical} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::CylindricalPoint{T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cylindrical}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\nFor cartesian grids:\n\nin(pt::CartesianPoint{3, T}, config::UserConfig{T})::Bool \nGrid(config::UserConfig{T})::Grid{T, 3, Cartesian} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::CartesianPoint{3, T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cartesian}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractImpurityDensity","page":"API","title":"SolidStateDetectors.AbstractImpurityDensity","text":"# abstract type AbstractImpurityDensity{T <: SSDFloat} end\n\nImpurity densities <: AbstractImpurityDensity should be defined to return (via get_impurity_density-method) a density of impurities in SI units, thus, in 1/m^3. For semiconductors, this will be converted internally into a charge distribution by multiplication with the elementary charge.  The sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. \n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantChargeDensity","page":"API","title":"SolidStateDetectors.ConstantChargeDensity","text":"struct ConstantChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nReturns always a fixed charge density.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantImpurityDensity","page":"API","title":"SolidStateDetectors.ConstantImpurityDensity","text":"struct ConstantImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nReturns always a fixed Impurity density.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"mutable struct Contact{T} <: AbstractContact{T}\n\nT: Type of precision.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalChargeDensity","page":"API","title":"SolidStateDetectors.CylindricalChargeDensity","text":"struct CylindricalChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each spatial dimension of a cylindrical coordinate system. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in r and z direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalImpurityDensity","page":"API","title":"SolidStateDetectors.CylindricalImpurityDensity","text":"struct CylindricalImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nSimple Impurity density model which assumes a linear gradient in Impurity density in each spatial dimension of a cylindrical coordinate system. offsets::NTuple{3, T} are the Impurity densities at 0 and gradients::NTuple{3, T} are the linear slopes in r and z direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis{T, BL, BR} <: AbstractAxis{T, BL, BR}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nBL: left boundary condition\nBR: right boundary condition\nI: IntervalSets.Interval (closed or open boundaries)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nL, R {:closed, :open} \nticks: Ticks of the axis\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricFieldChargeDriftModel","page":"API","title":"SolidStateDetectors.ElectricFieldChargeDriftModel","text":"ElectricFieldChargeDriftModel <: AbstractChargeDriftModel\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cartesian}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cartesian} ; kwargs...)::ElectricPotential{T, 3, Cartesian}\n\nExtracts the electric potential from setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::ElectricPotential{T, 3, Cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a huge amount of events.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"T: tick type\nN: N dimensional\nS: System (Cartesian, Cylindrical...)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearChargeDensity","page":"API","title":"SolidStateDetectors.LinearChargeDensity","text":"struct LinearChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension, x, y and z.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearImpurityDensity","page":"API","title":"SolidStateDetectors.LinearImpurityDensity","text":"struct LinearImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nSimple Impurity density model which assumes a linear gradient in Impurity density in each dimension of a Cartesian coordinate system. offsets::NTuple{3, T} are the Impurity densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension, x, y and z.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now there are:\n\n`const update_bit      = 0x01`\n`const undepleted_bit  = 0x02`\n`const pn_junction_bit = 0x04`\n\nHow to get information out of a PointType variable pt:\n\npt & update_bit == 0 -> do not update this point (for fixed points)     \npt & update_bit >  0 -> do update this point    \npt & undepleted_bit > 0 -> this point is undepleted\npt & pn_junction_bit > 0 -> this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes{T, N, S} <: AbstractArray{T, N}\n\nPointTypes stores the point type of each grid point.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::PointTypes{T, 3, Cylindrical}\n\nExtracts the point types from setup and extrapolates it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.PotentialSimulationSetup","page":"API","title":"SolidStateDetectors.PotentialSimulationSetup","text":"PotentialSimulationSetup{T, N, S} <: AbstractPotentialSimulationSetup{T, N}\n\nCollection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Simulation","page":"API","title":"SolidStateDetectors.Simulation","text":"mutable struct Simulation{T <: SSDFloat, CS <: AbstractCoordinateSystem} <: AbstractSimulation{T}\n\nCollection of all parts of a Simulation of a Solid State Detector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"mutable struct SolidStateDetector{T <: SSDFloat} <: AbstractConfig{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}","page":"API","title":"SolidStateDetectors.RBArray","text":"RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type, Grid{T, 3, Cartesian, AT} where AT}} where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, 3, Cartesian} )::Array{et, 4} where {T}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T}, 1}, Vector{T}, SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, PointTypes{T, 3, S}, Grid{T, 3, S, AT} where AT, CartesianPoint{T}, T, Interpolations.Extrapolation{var\"#s145\", 3, ITPT, IT, ET} where {var\"#s145\"<:(StaticArrays.StaticVector{3, T} where T), ITPT, IT, ET}}} where {T<:Union{Float16, Float32, Float64}, S}","page":"API","title":"SolidStateDetectors._drift_charge!","text":"_drift_charge!(...)\n\nBefore calling this function one should check that startpos is inside det: in(startpos, det)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdd Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state of the electric potential calculation. It overwrites sim.electric_potential, sim.q_eff_imp, sim.q_eff_fix, sim.ϵ and sim.point_types.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state of the weighting potential calculation for the contact with the id contact_id. It overwrites sim.weighting_potentials[contact_id].\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_capacitance","text":"calculate_capacitance(sim::Simulation{T})::T where {T <: SSDFloat}\n\nCalculates the capacitance of an detector in Farad.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_field!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Vararg{Any, N} where N}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.calculate_electric_field!","text":"calculate_electric_field!(sim::Simulation{T}, args...; n_points_in_φ::Union{Missing, Int} = missing, kwargs...)::Nothing\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_potential!","text":"calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing\n\nCompute the electric potential for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nmax_refinements::Int: Number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Tuple{<:Real, <:Real, <:Real}: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is r, φ, z).   A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is [1e-5, 1e-5, 1e-5].\ninit_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [1e-6, 1e-6, 1e-6].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(sim, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_weighting_potential!","text":"calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing\n\nCompute the weighting potential for the contact with id contact_id for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nmax_refinements::Int: Number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Tuple{<:Real, <:Real, <:Real}: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is r, φ, z).   A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is [1e-5, 1e-5, 1e-5].\ninit_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [1e-6, 1e-6, 1e-6].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(sim, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(pts::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_electron_drift_field","text":"get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_hole_drift_field","text":"get_hole_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the hole field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to example detector config files provided by the package.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64, Val{true}, Val{true}}","page":"API","title":"SolidStateDetectors.get_rbidx_right_neighbour","text":"get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nneeds docu...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cartesian, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cartesian},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            )::Nothing where {T, even_points, depletion_handling_enabled}\n\n(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cylindrical, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cylindrical},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                        )::Nothing where {T, even_points, depletion_handling_enabled}\n\n(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.nidx-Tuple{Int64, Val{true}, Val{true}}","page":"API","title":"SolidStateDetectors.nidx","text":"nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nfirst type argument:  type of the orgal point (for even points -> Val{true}(), else Val{false}()) second type argument: is sum of other point indices even or odd -> (if sum is even -> Val{true}(), else Val{false}())\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"parse_config_file(filename::AbstractString)::SolidStateDetector{T} where {T <: SSDFloat}\n\nReads in a config file and returns an Detector struct which holds all information specified in the config file. Currently supported formats for the config file: .json, .yaml\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, Grid{T, 3, S, AT} where {S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}, CartesianPoint{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.point_type","text":"For charge drift...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.readsiggen-Tuple{String}","page":"API","title":"SolidStateDetectors.readsiggen","text":"readsiggen(file_path::String[, T::Type=Float64])\n\nRead the '*.config' file in 'file_path' for SigGen and returns a dictionary of all parameters. Non-existing parameteres are set to 0. ...\n\nArguments\n\nfile_path::String: file path for the SigGen config file.\nT::Type=Float64: type of the parameters in the output dictionary.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.electric_potential and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.weighting_potentials[contact_id] and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.siggentodict-Tuple{Dict}","page":"API","title":"SolidStateDetectors.siggentodict","text":"siggentodict(config::Dict[, units::Dict, detector_name::String])\n\nConverts the dictionary containing the parameters from a SigGen config file to a SSD config dictionary. This dictionary can be saved as a JSON file using the JSON package and 'JSON.print(file, config, 4)'. The 'detector_name' is set to \"Public Inverted Coax\" by default to inherit the colour scheme. ...\n\nArguments\n\nconfig::Dict: dictionary containing SigGen parameters (output of readsiggen()).\nunits::Dict: units used in SigGen file (set to 'mm', 'deg', 'V' and 'K').\ndetector_name::String: name of the detector.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"function simulate!(sim::Simulation{T};  max_refinements::Int = 1, verbose::Bool = false,\n                                    depletion_handling::Bool = false, convergence_limit::Real = 1e-5 ) where {T <: SSDFloat}\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, S, TGW, AT} where {TGW, AT}, Int64, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, S, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}","page":"API","title":"SolidStateDetectors.update!","text":"update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing\n\nLoop over even grid points. A point is even if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -> rbpotential[ inds..., rbi ]).\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.electric_potential and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.weighting_potentials[contact_id] and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry","text":"module ConstructiveSolidGeometry\n\n\n\n\n\n","category":"module"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Box","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Box","text":"Box{T, CO} <: AbstractVolumePrimitive{T}\n\nT: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive <-> whether surface belongs to it or not\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","text":"struct CSGDifference{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na && !b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","text":"struct CSGIntersection{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na && b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","text":"struct CSGUnion{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\na || b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","text":"struct CartesianPoint{T} <: AbstractCoordinatePoint{T, Cartesian}\n\nx: x-coordinate in meter\ny: y-coordinate in meter\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","text":"struct CartesianVector{T} <: AbstractCoordinateVector{T, Cartesian}\n\nx: x-component in meter\ny: y-component in meter\nz: z-component in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Cone","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Cone","text":"struct Cone{T,CO,TR,TP} <: AbstractVolumePrimitive{T, CO}\n\nT: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive <-> whether surface belongs to it or not\n\nr::TR: \nTR = Real -> Cylinder\nTR = (Real, Real) -> Tube (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) Solid widening Cylinder  -> (rbot = r[1][1], rtop = r[1][2])\nTR = ((Real,Real), (Real,Real)) Solid widening Tube ->\n\n(rbotin = r[1][1], rbotout = r[1][2], rtopin = r[2][1], rtopout = r[2][2])     * TR = (Nothing, (Real,Real)) Cone -> (rbotin = rbotout = 0, rtopin = r[2][1], rtopout = r[2][2])     * TR = ((Real,Real), Nothing) Cone -> (rbotin = r[1][1], rbotout = r[1][2], rtopin = rtopout = 0)     * ... (+ elliptical cases -> (a, b))     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\nzH::T: half hight/length of the cone\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","text":"struct ConeMantle{T,TR,TP,D} <: AbstractSurfacePrimitive{T}\n\nT: Type of values, e.g. Float64\n\nr::TR: \nTR = Real -> Cylinder Mantle (a = b = r)\nTR = (Real, Real) -> Cone Mantle (rbot = r[1], rtop = r[2]) \nTR = ((Real,), (Real,)) -> Elliptical Cylinder Mantle (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Cone Mantle \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\nhZ::T: half hight/length of the cone mantle\nD: :inwards or :outwards: Whethe the normal points inside or outside\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","text":"struct CylindricalPoint{T} <: AbstractCoordinatePoint{T, Cylindrical}\n\nr: Radius in meter\nφ: Polar angle in radians. φ == 0 <=> Parallel to x-axis of cartesian coordinate system.\"\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","text":"struct CylindricalVector{T} <: AbstractCoordinateVector{T, Cylindrical}\n\nr: Radius in meter\nφ: Polar angle in radians. φ == 0 <=> Parallel to x-axis of cartesian coordinate system.\"\nz: z-coordinate in meter\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Ellipse","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Ellipse","text":"struct Ellipse{T,TR} <: AbstractLinePrimitive{T}\n\nr::TR: \nTR = Real -> Circle (a = b = r)\nTR = (Real, Real) -> Circular Annulus (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) -> Ellipse (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Annulus \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","text":"EllipticalSurface{T,TR,TP} <: AbstractSurfacePrimitive{T}\n\nr::TR: \nTR = Real -> Full Circle (a = b = r)\nTR = (Real, Real) -> Circular Annulus (rin = r[1], rout = r[2])\nTR = ((Real,), (Real,)) -> Full Ellipse (a = r[1][1], b = r[2][1])\nTR = ((Real, Real),(Real, Real)) -> Elliptical Annulus \n\n(ain = r[1][1], aout = r[1][2], bin = r[2][1], bout = r[2][2])     * Not all are implemented yet\n\nφ::TP: \nTP = Nothing <-> Full in φ\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.extreme_points","text":"extreme_points(es::AbstractPrimitive{T}) where {T}\n\nGeneral implementation for all primitives.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::EllipsoidMantle{T,T}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::EllipsoidMantle{T,NTuple{3,T}}, l::Line{T}) where {T}\n\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(tm::TorusMantle{T}, l::Line{T}) where {T}\n\nThe function will always return 4 CartesianPoint's. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN's as there coordinates.\n\nSolve: solve (sqrt((L1 + λ*D1)^2 + (L2 + λ*D2)^2)-R)^2 + (L3 + λ*D3)^2 = r^2 for λ\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial-Union{Tuple{T}, NTuple{4, T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial","text":"roots_of_4th_order_polynomial(a::T, b::T, c::T, d::T, e::T)\n\nCalculate the 4 (possible) roots of x^4 + ax^3 + bx^2 + cx + d = 0\n\n\n\n\n\n","category":"method"},{"location":"man/electric_fields/#Electric-Fields","page":"Electric Fields","title":"Electric Fields","text":"","category":"section"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"After the electric potential is calculated, the electric field is calculated for each grid point (ijk):","category":"page"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"vecE^ijk = left( mathcalE_r^ijk mathcalE_varphi^ijk mathcalE_z^ijk right)^mathsfT","category":"page"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"where the elements are the means of the electric field in each direction calculated as finite differences:","category":"page"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"beginaligned\n\tmathcalE_r^ijk = dfrac12left(dfracPhi_i+1jk-Phi_ijkr_i+1 - r_i + dfracPhi_ijk-Phi_i-1jkr_i - r_i-1right)hspace10pt\n\tmathcalE_varphi^ijk = dfrac12 r_ileft(dfracPhi_ij+1k-Phi_ijkvarphi_j+1 - varphi_j + dfracPhi_ijk-Phi_ij-1kvarphi_j - varphi_j-1right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"This discrete electric field is interpolated (via Interpolations.jl)  during the drift in order to get the electric field at the current position of the charge carrier.","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#SolidStateDetectors.jl","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/primitives.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_fields.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/drift_fields.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Example-1:-Inverted-Coax-Detector","page":"Tutorial","title":"Example 1: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsimulation = Simulation{T}(SSD_examples[:InvertedCoax])\n\nplot(simulation.detector)\nsavefig(\"tutorial_det.pdf\") # hide\nsavefig(\"tutorial_det.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_det)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"apply_initial_state!(simulation, ElectricPotential) # optional\nplot(\n    plot(simulation.electric_potential), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.q_eff_imp), # charge density distribution\n    plot(simulation.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_initial_condition.pdf\") # hide\nsavefig(\"tutorial_initial_condition.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_initial_condition)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, calculate the electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_potential!( simulation,\n                               max_refinements = 3)\n\nplot(\n    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.q_eff_imp), # charge density distribution\n    plot(simulation.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_calculated_potential.pdf\") # hide\nsavefig(\"tutorial_calculated_potential.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"tutorial/#Partially-depleted-detectors","page":"Tutorial","title":"Partially depleted detectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulation_undep = deepcopy(simulation)\nsimulation_undep.detector = SolidStateDetector(simulation_undep.detector, contact_id = 2, contact_potential = 500); # V  <-- Bias Voltage of Mantle\n\ncalculate_electric_potential!( simulation_undep,\n                               depletion_handling = true,\n                               convergence_limit=1e-6,\n                               max_refinements = 3,\n                               verbose = false)\n\n\nplot(\n    plot(simulation_undep.electric_potential),\n    plot(simulation_undep.point_types),\n    layout = (1, 2), size = (800, 700)\n)\nsavefig(\"tutorial_calculated_potential_undep.pdf\") # hide\nsavefig(\"tutorial_calculated_potential_undep.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential_undep)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare both volumes:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Depleted:   \", get_active_volume(simulation.point_types))\nprintln(\"Undepleted: \", get_active_volume(simulation_undep.point_types));\nnothing #hide","category":"page"},{"location":"tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_field!(simulation, n_points_in_φ = 72)\n\nplot(simulation.electric_field, full_det = true, φ = 0.0, size = (500, 500))\nplot_electric_fieldlines!(simulation, full_det = true, φ = 0.0)\nsavefig(\"tutorial_electric_field.pdf\") # hide\nsavefig(\"tutorial_electric_field.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_electric_field)","category":"page"},{"location":"tutorial/#Drift-field-calculation","page":"Tutorial","title":"Drift field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the Bruyneel model from the Agata Data Library (ADL) is used. Other configurations are saved in their configuration files and can be found under:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<package_directory>/examples/example_config_files/ADLChargeDriftModel/<config_filename>.yaml.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set the charge drift model of the simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"charge_drift_model = ADLChargeDriftModel()\nsimulation.detector = SolidStateDetector(simulation.detector, charge_drift_model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And apply the charge drift model to the electric field:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_drift_fields!(simulation)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's create an \"random\" (multiside) event:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevent = Event(starting_positions, energy_depos);\n\ntime_step = 5u\"ns\"\ndrift_charges!(event, simulation, Δt = time_step)\n\nplot(simulation.detector, size = (700, 700))\nplot!(event.drift_paths)\nsavefig(\"tutorial_drift_paths.pdf\") # hide\nsavefig(\"tutorial_drift_paths.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_drift_paths)","category":"page"},{"location":"tutorial/#Weighting-potential-calculation","page":"Tutorial","title":"Weighting potential calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for contact in simulation.detector.contacts\n    calculate_weighting_potential!(simulation, contact.id, max_refinements = 3, n_points_in_φ = 2, verbose = false)\nend\n\nplot(\n    plot(simulation.weighting_potentials[1]),\n    plot(simulation.weighting_potentials[2]),\n    size = (900, 700)\n)\nsavefig(\"tutorial_weighting_potentials.pdf\") # hide\nsavefig(\"tutorial_weighting_potentials.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_weighting_potentials)","category":"page"},{"location":"tutorial/#Detector-waveform-generation","page":"Tutorial","title":"Detector waveform generation","text":"","category":"section"},{"location":"tutorial/#Single-event-simulation","page":"Tutorial","title":"Single-event simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulate!(event, simulation) # drift_charges + signal generation of all channels\n\np_pc_signal = plot( event.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = \"Time / ns\",\n                    legend = false, tickfontsize = 12, ylabel = \"Energy / eV\", guidefontsize = 14)\nsavefig(\"tutorial_waveforms.pdf\") # hide\nsavefig(\"tutorial_waveforms.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_waveforms)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
