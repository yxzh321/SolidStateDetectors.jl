<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SolidStateDetectors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Detectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/config_files/">Configuration Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Geometries (CSG)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/csg/">CSG</a></li><li><a class="tocitem" href="../man/primitives/">Primitives</a></li></ul></li><li><a class="tocitem" href="../man/electric_potentials/">Electric Potentials</a></li><li><a class="tocitem" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../man/electric_fields/">Electric Fields</a></li><li><a class="tocitem" href="../man/drift_fields/">Drift Fields</a></li><li><a class="tocitem" href="../man/IO/">IO</a></li></ul></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry"><code>SolidStateDetectors.ConstructiveSolidGeometry</code></a></li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.AbstractChargeDensity"><code>SolidStateDetectors.AbstractChargeDensity</code></a></li><li><a href="#SolidStateDetectors.AbstractConfig"><code>SolidStateDetectors.AbstractConfig</code></a></li><li><a href="#SolidStateDetectors.AbstractImpurityDensity"><code>SolidStateDetectors.AbstractImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.ConstantChargeDensity"><code>SolidStateDetectors.ConstantChargeDensity</code></a></li><li><a href="#SolidStateDetectors.ConstantImpurityDensity"><code>SolidStateDetectors.ConstantImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Box"><code>SolidStateDetectors.ConstructiveSolidGeometry.Box</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>SolidStateDetectors.ConstructiveSolidGeometry.Cone</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Ellipse"><code>SolidStateDetectors.ConstructiveSolidGeometry.Ellipse</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface</code></a></li><li><a href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a></li><li><a href="#SolidStateDetectors.CylindricalChargeDensity"><code>SolidStateDetectors.CylindricalChargeDensity</code></a></li><li><a href="#SolidStateDetectors.CylindricalImpurityDensity"><code>SolidStateDetectors.CylindricalImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.ElectricFieldChargeDriftModel"><code>SolidStateDetectors.ElectricFieldChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a></li><li><a href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cartesian}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a></li><li><a href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a></li><li><a href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a></li><li><a href="#SolidStateDetectors.LinearChargeDensity"><code>SolidStateDetectors.LinearChargeDensity</code></a></li><li><a href="#SolidStateDetectors.LinearImpurityDensity"><code>SolidStateDetectors.LinearImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a></li><li><a href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.PotentialSimulationSetup"><code>SolidStateDetectors.PotentialSimulationSetup</code></a></li><li><a href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a></li><li><a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.extreme_points</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial-Union{Tuple{T}, NTuple{4, T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial</code></a></li><li><a href="#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}"><code>SolidStateDetectors.RBArray</code></a></li><li><a href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}"><code>SolidStateDetectors.RBExtBy2Array</code></a></li><li><a href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type, Grid{T, 3, Cartesian, AT} where AT}} where T"><code>SolidStateDetectors.RBExtBy2Array</code></a></li><li><a href="#SolidStateDetectors._convert_to_original_potential-Union{Tuple{ATO}, Tuple{AT}, Tuple{CS}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, 3, CS, ATO}, ElectricPotential{T, 3, CS, ATO}, PointTypes{T, 3, CS, ATO}, WeightingPotential{T, 3, CS, ATO}}, Array{T, 3}, Grid{T, 3, CS, AT}}} where {T, CS, AT, ATO}"><code>SolidStateDetectors._convert_to_original_potential</code></a></li><li><a href="#SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T}, 1}, Vector{T}, SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, PointTypes{T, 3, S, AT} where AT, Grid{T, 3, S, AT} where AT, CartesianPoint{T}, T, Interpolations.Extrapolation{var&quot;#s145&quot;, 3, ITPT, IT, ET} where {var&quot;#s145&quot;&lt;:(StaticArrays.StaticVector{3, T} where T), ITPT, IT, ET}}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors._drift_charge!</code></a></li><li><a href="#SolidStateDetectors._get_closed_potential-Union{Tuple{Union{EffectiveChargeDensity{T, 3, CS, AT}, ElectricPotential{T, 3, CS, AT}, PointTypes{T, 3, CS, AT}, WeightingPotential{T, 3, CS, AT}} where AT}, Tuple{CS}, Tuple{T}} where {T, CS}"><code>SolidStateDetectors._get_closed_potential</code></a></li><li><a href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_capacitance</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Vararg{Any, N} where N}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.calculate_electric_field!</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a></li><li><a href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a></li><li><a href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical, AT} where AT}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a></li><li><a href="#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_electron_drift_field</code></a></li><li><a href="#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_hole_drift_field</code></a></li><li><a href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a></li><li><a href="#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64, Val{true}, Val{true}}"><code>SolidStateDetectors.get_rbidx_right_neighbour</code></a></li><li><a href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cylindrical, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.innerloops!</code></a></li><li><a href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cartesian, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.innerloops!</code></a></li><li><a href="#SolidStateDetectors.nidx-Tuple{Int64, Val{true}, Val{true}}"><code>SolidStateDetectors.nidx</code></a></li><li><a href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a></li><li><a href="#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, Grid{T, 3, S, AT} where {S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}, CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.point_type</code></a></li><li><a href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.refine_scalar_potential-Union{Tuple{only_2d}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, N, S, AT}, ElectricPotential{T, N, S, AT}, PointTypes{T, N, S, AT}, WeightingPotential{T, N, S, AT}} where {N, S, AT}, Tuple{T, T, T}, Tuple{T, T, T}}} where {T, only_2d}"><code>SolidStateDetectors.refine_scalar_potential</code></a></li><li><a href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a></li><li><a href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a></li><li><a href="#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, S, TGW, AT} where {TGW, AT}, Int64, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, S, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.update!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a></li></ul><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ADLChargeDriftModel" href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ADLChargeDriftModel{T &lt;: SSDFloat, M &lt;: AbstractDriftMaterial, N, TM &lt;: AbstractTemperatureModel{T}} &lt;: AbstractChargeDriftModel{T}</code></pre><p><strong>Fields</strong></p><ul><li><code>electrons::CarrierParameters{T}</code></li><li><code>holes::CarrierParameters{T}</code></li><li><code>crystal_orientation::SMatrix{3,3,T,9}</code></li><li><code>γ::SVector{N,SMatrix{3,3,T,9}}</code></li><li><code>parameters::ADLParameters{T}</code></li><li><code>temperaturemodel::TM</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDriftModels/ADL/ADL.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractChargeDensity" href="#SolidStateDetectors.AbstractChargeDensity"><code>SolidStateDetectors.AbstractChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"># abstract type AbstractChargeDensity{T &lt;: SSDFloat} end</code></pre><p>Charge densities &lt;: <code>AbstractChargeDensity</code> should be defined to return (via <code>get_charge_density</code>-method) a charge density in SI units, thus, in Q/m^3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDensities/ChargeDensities.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractConfig" href="#SolidStateDetectors.AbstractConfig"><code>SolidStateDetectors.AbstractConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConfig{T &lt;: SSDFloat} end</code></pre><p>Supertype of all detector/world/object configs.</p><p>User defined geometries must be subtype of <code>AbstractConfig{T}</code>.</p><p>There are a few functions which must be defined for a user config, e.g. <code>struct UserConfig{T} &lt;: AbstractConfig{T}</code>:</p><p>For cylindrical grids:</p><ul><li>in(pt::CylindricalPoint{T}, config::UserConfig{T})::Bool where {T &lt;: SSDFloat}</li><li>Grid(config::UserConfig{T})::Grid{T, 3, Cylindrical} where {T &lt;: SSDFloat}</li><li>get_ρ_and_ϵ(pt::CylindricalPoint{T}, config::UserConfig{T})::Tuple{T, T} where {T &lt;: SSDFloat} </li><li>set_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cylindrical}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T &lt;: SSDFloat}</li></ul><p>For cartesian grids:</p><ul><li>in(pt::CartesianPoint{3, T}, config::UserConfig{T})::Bool </li><li>Grid(config::UserConfig{T})::Grid{T, 3, Cartesian} where {T &lt;: SSDFloat}</li><li>get_ρ_and_ϵ(pt::CartesianPoint{3, T}, config::UserConfig{T})::Tuple{T, T} where {T &lt;: SSDFloat} </li><li>set_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, Cartesian}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T &lt;: SSDFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Config/Config.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractImpurityDensity" href="#SolidStateDetectors.AbstractImpurityDensity"><code>SolidStateDetectors.AbstractImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"># abstract type AbstractImpurityDensity{T &lt;: SSDFloat} end</code></pre><p>Impurity densities &lt;: <code>AbstractImpurityDensity</code> should be defined to return (via <code>get_impurity_density</code>-method) a density of impurities in SI units, thus, in 1/m^3. For semiconductors, this will be converted internally into a charge distribution by multiplication with the elementary charge.  The sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ImpurityDensities/ImpurityDensities.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstantChargeDensity" href="#SolidStateDetectors.ConstantChargeDensity"><code>SolidStateDetectors.ConstantChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Returns always a fixed charge density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDensities/ConstantChargeDensity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstantImpurityDensity" href="#SolidStateDetectors.ConstantImpurityDensity"><code>SolidStateDetectors.ConstantImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Returns always a fixed Impurity density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ImpurityDensities/ConstantImpurityDensity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Contact" href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Contact{T} &lt;: AbstractContact{T}</code></pre><p>T: Type of precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/Contacts.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.CylindricalChargeDensity" href="#SolidStateDetectors.CylindricalChargeDensity"><code>SolidStateDetectors.CylindricalChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Simple charge density model which assumes a linear gradient in charge density in each spatial dimension of a cylindrical coordinate system. <code>offsets::NTuple{3, T}</code> are the charge densities at 0 and <code>gradients::NTuple{3, T}</code> are the linear slopes in <code>r</code> and <code>z</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDensities/CylindricalChargeDensity.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.CylindricalImpurityDensity" href="#SolidStateDetectors.CylindricalImpurityDensity"><code>SolidStateDetectors.CylindricalImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Simple Impurity density model which assumes a linear gradient in Impurity density in each spatial dimension of a cylindrical coordinate system. <code>offsets::NTuple{3, T}</code> are the Impurity densities at 0 and <code>gradients::NTuple{3, T}</code> are the linear slopes in <code>r</code> and <code>z</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ImpurityDensities/CylindricalImpurityDensity.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis" href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscreteAxis{T, BL, BR} &lt;: AbstractAxis{T, BL, BR}</code></pre><ul><li>T: Type of ticks</li><li>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} </li><li>BL: left boundary condition</li><li>BR: right boundary condition</li><li>I: IntervalSets.Interval (closed or open boundaries)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Axes/DiscreteAxis.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T" href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}</code></pre><ul><li>T: Type of ticks</li><li>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} </li><li>L, R {:closed, :open} </li><li>ticks: Ticks of the axis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Axes/DiscreteAxis.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricFieldChargeDriftModel" href="#SolidStateDetectors.ElectricFieldChargeDriftModel"><code>SolidStateDetectors.ElectricFieldChargeDriftModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElectricFieldChargeDriftModel &lt;: AbstractChargeDriftModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDriftModels/Vacuum/Vacuum.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cartesian}}, Tuple{T}} where T" href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cartesian}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cartesian} ; kwargs...)::ElectricPotential{T, 3, Cartesian}</code></pre><p>Extracts the electric potential from <code>setup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/ElectricPotential.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElectricPotential(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::ElectricPotential{T, 3, Cylindrical}</code></pre><p>Extracts the electric potential from <code>setup</code> and extrapolate it to an 2π grid.</p><p>For 2D grids (r and z) the user has to set the keyword <code>n_points_in_φ::Int</code>, e.g.: <code>n_points_in_φ = 36</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/ElectricPotential.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Event" href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Event{T &lt;: SSDFloat}</code></pre><p>Collection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a huge amount of events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Event/Event.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Grid" href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">T: tick type
N: N dimensional
S: System (Cartesian, Cylindrical...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Grids/Grids.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LinearChargeDensity" href="#SolidStateDetectors.LinearChargeDensity"><code>SolidStateDetectors.LinearChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LinearChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Simple charge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system. <code>offsets::NTuple{3, T}</code> are the charge densities at 0 and <code>gradients::NTuple{3, T}</code> are the linear slopes in each dimension, <code>x</code>, <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDensities/LinearChargeDensity.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LinearImpurityDensity" href="#SolidStateDetectors.LinearImpurityDensity"><code>SolidStateDetectors.LinearImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LinearImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Simple Impurity density model which assumes a linear gradient in Impurity density in each dimension of a Cartesian coordinate system. <code>offsets::NTuple{3, T}</code> are the Impurity densities at 0 and <code>gradients::NTuple{3, T}</code> are the linear slopes in each dimension, <code>x</code>, <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ImpurityDensities/LinearImpurityDensity.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointType" href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PointType = UInt8</code></pre><p>Stores certain information about a grid point via bit-flags. </p><p>Right now there are:</p><pre><code class="nohighlight hljs">`const update_bit      = 0x01`
`const undepleted_bit  = 0x02`
`const pn_junction_bit = 0x04`</code></pre><p>How to get information out of a PointType variable <code>pt</code>:</p><ol><li><code>pt &amp; update_bit == 0</code> -&gt; do not update this point (for fixed points)     </li><li><code>pt &amp; update_bit &gt;  0</code> -&gt; do update this point    </li><li><code>pt &amp; undepleted_bit &gt; 0</code> -&gt; this point is undepleted</li><li><code>pt &amp; pn_junction_bit &gt; 0</code> -&gt; this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Types/point_types.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointTypes" href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointTypes{T, N, S} &lt;: AbstractArray{T, N}</code></pre><p>PointTypes stores the point type of each grid point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Types/point_types.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointTypes(setup::PotentialSimulationSetup{T, 3, Cylindrical} ; kwargs...)::PointTypes{T, 3, Cylindrical}</code></pre><p>Extracts the point types from <code>setup</code> and extrapolates it to an 2π grid.</p><p>For 2D grids (r and z) the user has to set the keyword <code>n_points_in_φ::Int</code>, e.g.: <code>n_points_in_φ = 36</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/PotentialSimulationSetups/PotentialSimulationSetupRBCylindrical.jl#L433-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PotentialSimulationSetup" href="#SolidStateDetectors.PotentialSimulationSetup"><code>SolidStateDetectors.PotentialSimulationSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PotentialSimulationSetup{T, N, S} &lt;: AbstractPotentialSimulationSetup{T, N}</code></pre><p>Collection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/PotentialSimulationSetups/PotentialSimulationSetups.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Simulation" href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Simulation{T &lt;: SSDFloat, CS &lt;: AbstractCoordinateSystem} &lt;: AbstractSimulation{T}</code></pre><p>Collection of all parts of a Simulation of a Solid State Detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.SolidStateDetector" href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SolidStateDetector{T &lt;: SSDFloat} &lt;: AbstractConfig{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/SolidStateDetector.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}" href="#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}"><code>SolidStateDetectors.RBArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/RedBlack/RedBlack.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}" href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type, Grid{T, N, Cylindrical, AT} where AT}} where {T, N}"><code>SolidStateDetectors.RBExtBy2Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RBExtBy2Array( et::Type, g::Grid{T, N, Cylindrical} )::Array{et, N + 1} where {T, N}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. The RedBlack array is extended in its size by 2 in each geometrical dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/RedBlack/RedBlack.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type, Grid{T, 3, Cartesian, AT} where AT}} where T" href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type, Grid{T, 3, Cartesian, AT} where AT}} where T"><code>SolidStateDetectors.RBExtBy2Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RBExtBy2Array( et::Type, g::Grid{T, 3, Cartesian} )::Array{et, 4} where {T}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. The RedBlack array is extended in its size by 2 in each geometrical dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/RedBlack/RedBlack.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors._convert_to_original_potential-Union{Tuple{ATO}, Tuple{AT}, Tuple{CS}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, 3, CS, ATO}, ElectricPotential{T, 3, CS, ATO}, PointTypes{T, 3, CS, ATO}, WeightingPotential{T, 3, CS, ATO}}, Array{T, 3}, Grid{T, 3, CS, AT}}} where {T, CS, AT, ATO}" href="#SolidStateDetectors._convert_to_original_potential-Union{Tuple{ATO}, Tuple{AT}, Tuple{CS}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, 3, CS, ATO}, ElectricPotential{T, 3, CS, ATO}, PointTypes{T, 3, CS, ATO}, WeightingPotential{T, 3, CS, ATO}}, Array{T, 3}, Grid{T, 3, CS, AT}}} where {T, CS, AT, ATO}"><code>SolidStateDetectors._convert_to_original_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_convert_to_original_potential(::Type{P}, data, grid) where {P, T, CS}</code></pre><p>Basically the counterpart to <code>_get_closed_potential</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/ConvergenceAndRefinement.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T}, 1}, Vector{T}, SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, PointTypes{T, 3, S, AT} where AT, Grid{T, 3, S, AT} where AT, CartesianPoint{T}, T, Interpolations.Extrapolation{var&quot;#s145&quot;, 3, ITPT, IT, ET} where {var&quot;#s145&quot;&lt;:(StaticArrays.StaticVector{3, T} where T), ITPT, IT, ET}}} where {T&lt;:Union{Float16, Float32, Float64}, S}" href="#SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T}, 1}, Vector{T}, SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, PointTypes{T, 3, S, AT} where AT, Grid{T, 3, S, AT} where AT, CartesianPoint{T}, T, Interpolations.Extrapolation{var&quot;#s145&quot;, 3, ITPT, IT, ET} where {var&quot;#s145&quot;&lt;:(StaticArrays.StaticVector{3, T} where T), ITPT, IT, ET}}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors._drift_charge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_drift_charge!(...)</code></pre><p>Before calling this function one should check that <code>startpos</code> is inside <code>det</code>: <code>in(startpos, det)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDrift/ChargeDrift.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors._get_closed_potential-Union{Tuple{Union{EffectiveChargeDensity{T, 3, CS, AT}, ElectricPotential{T, 3, CS, AT}, PointTypes{T, 3, CS, AT}, WeightingPotential{T, 3, CS, AT}} where AT}, Tuple{CS}, Tuple{T}} where {T, CS}" href="#SolidStateDetectors._get_closed_potential-Union{Tuple{Union{EffectiveChargeDensity{T, 3, CS, AT}, ElectricPotential{T, 3, CS, AT}, PointTypes{T, 3, CS, AT}, WeightingPotential{T, 3, CS, AT}} where AT}, Tuple{CS}, Tuple{T}} where {T, CS}"><code>SolidStateDetectors._get_closed_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_closed_potential(p::ScalarPotential{T,3,CS}) where {T, CS}</code></pre><p>Returns an closed Grid &amp; Potential: E.g. if one of the axis is {:closed,:open} it will turn this into {:closed,:closed} and also extend the <code>data</code> field of the potential in the respective dimension and fill it with the respective values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/ConvergenceAndRefinement.jl#L170-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.add_fano_noise" href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity</code></pre><p>Add Fano noise to an energy deposition <code>E_dep</code>, assuming a detector material ionisation energy <code>E_ionisation</code> and a Fano factor <code>f_fano</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeStatistics/ChargeStatistics.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim))::Nothing</code></pre><p>Applies the initial state of the electric potential calculation. It overwrites <code>sim.electric_potential</code>, <code>sim.q_eff_imp</code>, <code>sim.q_eff_fix</code>, <code>sim.ϵ</code> and <code>sim.point_types</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing</code></pre><p>Applies the initial state of the weighting potential calculation for the contact with the id <code>contact_id</code>. It overwrites <code>sim.weighting_potentials[contact_id]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L400-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_capacitance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_capacitance(sim::Simulation{T})::T where {T &lt;: SSDFloat}</code></pre><p>Calculates the capacitance of an detector in Farad.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L1043-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_field!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Vararg{Any, N} where N}} where {T&lt;:Union{Float16, Float32, Float64}, CS}" href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Vararg{Any, N} where N}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.calculate_electric_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_electric_field!(sim::Simulation{T}, args...; n_points_in_φ::Union{Missing, Int} = missing, kwargs...)::Nothing</code></pre><p>ToDo...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L822-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing</code></pre><p>Compute the electric potential for the given Simulation <code>sim</code> on an adaptive grid through successive over relaxation.</p><p>There are several <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>2e-6</code> (times bias voltage).</li><li><code>refinement_limits</code>: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the i-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and <code>0.25 * r_max</code> for the polar axis in case of a cylindrical grid.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>grid::Grid</code>: Initial grid used to start the simulation. Default is <code>Grid(sim)</code>.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is false.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L774-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing</code></pre><p>Compute the weighting potential for the contact with id <code>contact_id</code> for the given Simulation <code>sim</code> on an adaptive grid through successive over relaxation.</p><p>There are several <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>2e-6</code> (times bias voltage).</li><li><code>refinement_limits</code>: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the i-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and <code>0.25 * r_max</code> for the polar axis in case of a cylindrical grid.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>grid::Grid</code>: Initial grid used to start the simulation. Default is <code>Grid(sim)</code>.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is false.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L727-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical, AT} where AT}, Tuple{T}} where T" href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical, AT} where AT}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_active_volume(pts::PointTypes{T}) where {T}</code></pre><p>Returns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Types/point_types.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_electron_drift_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T &lt;: SSDFloat}</code></pre><p>Applies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDriftModels/ChargeDriftModels.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_hole_drift_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_hole_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T &lt;: SSDFloat}</code></pre><p>Applies the charge drift model onto the hole field vectors. The field vectors have to be in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ChargeDriftModels/ChargeDriftModels.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_path_to_example_config_files-Tuple{}" href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_path_to_example_config_files()::String</code></pre><p>Returns the path to example detector config files provided by the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/examples.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64, Val{true}, Val{true}}" href="#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64, Val{true}, Val{true}}"><code>SolidStateDetectors.get_rbidx_right_neighbour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int</code></pre><p>needs docu...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/RedBlack/RedBlack.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cartesian, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}" href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cartesian, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.innerloops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cartesian},
                            update_even_points::Val{even_points},
                            depletion_handling::Val{depletion_handling_enabled},
                            )::Nothing where {T, even_points, depletion_handling_enabled}</code></pre><p>(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/SimulationAlgorithms/Cartesian3D.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cylindrical, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}" href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64, Int64, Int64, Matrix{T}, Matrix{T}, Matrix{T}, SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, Cylindrical, TGW, AT} where {TGW, AT}, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.innerloops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, Cylindrical},
                            update_even_points::Val{even_points},
                            depletion_handling::Val{depletion_handling_enabled},
                        )::Nothing where {T, even_points, depletion_handling_enabled}</code></pre><p>(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/SimulationAlgorithms/Cylindrical.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.nidx-Tuple{Int64, Val{true}, Val{true}}" href="#SolidStateDetectors.nidx-Tuple{Int64, Val{true}, Val{true}}"><code>SolidStateDetectors.nidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int</code></pre><p>first type argument:  type of the orgal point (for even points -&gt; <code>Val{true}()</code>, else <code>Val{false}()</code>) second type argument: is sum of other point indices even or odd -&gt; (if sum is even -&gt; <code>Val{true}()</code>, else <code>Val{false}()</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/RedBlack/RedBlack.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.parse_config_file-Tuple{AbstractString}" href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_config_file(filename::AbstractString)::SolidStateDetector{T} where {T &lt;: SSDFloat}</code></pre><p>Reads in a config file and returns an Detector struct which holds all information specified in the config file. Currently supported formats for the config file: .json, .yaml</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/DetectorGeometries.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, Grid{T, 3, S, AT} where {S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}, CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T, SC, CT, PT, VDM} where {SC, CT, PT, VDM}, Grid{T, 3, S, AT} where {S&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}, CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.point_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">For charge drift...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/DetectorGeometries.jl#L172-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.readsiggen-Tuple{String}" href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readsiggen(file_path::String[, T::Type=Float64])</code></pre><p>Read the &#39;*.config&#39; file in &#39;file_path&#39; for SigGen and returns a dictionary of all parameters. Non-existing parameteres are set to 0. ...</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: file path for the SigGen config file.</li><li><code>T::Type=Float64</code>: type of the parameters in the output dictionary.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/SigGenInterface.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}, minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real})</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L546-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}, minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real})</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L569-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine_scalar_potential-Union{Tuple{only_2d}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, N, S, AT}, ElectricPotential{T, N, S, AT}, PointTypes{T, N, S, AT}, WeightingPotential{T, N, S, AT}} where {N, S, AT}, Tuple{T, T, T}, Tuple{T, T, T}}} where {T, only_2d}" href="#SolidStateDetectors.refine_scalar_potential-Union{Tuple{only_2d}, Tuple{T}, Tuple{Union{EffectiveChargeDensity{T, N, S, AT}, ElectricPotential{T, N, S, AT}, PointTypes{T, N, S, AT}, WeightingPotential{T, N, S, AT}} where {N, S, AT}, Tuple{T, T, T}, Tuple{T, T, T}}} where {T, only_2d}"><code>SolidStateDetectors.refine_scalar_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_scalar_potential(p::ScalarPotential{T}, max_diffs::NTuple{3, T}, minimum_distances::NTuple{3, T}; 
    only2d::Val{only_2d} = Val(size(p.data, 2)==1)) where {T, only_2d}</code></pre><p>Refine any scalar potential <code>p</code>. </p><ol><li>Extent the grid to be a closed grid in all dimensions. </li><li>Refine the axis of the grid based on <code>max_diffs</code> and <code>minimum_applied_potential</code>: Insert N new ticks between to existing ticks such that the potential difference between each tick becomes smaller than <code>max_diff[i]</code> (i -&gt; dimension) but that the distances between the ticks stays larger than <code>minimum_distances[i]</code>.</li><li>Create the new data array for the refined grid and fill it by interpolation of the the initial (coarse) grid.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/ConvergenceAndRefinement.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.siggentodict-Tuple{Dict}" href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siggentodict(config::Dict[, units::Dict, detector_name::String])</code></pre><p>Converts the dictionary containing the parameters from a SigGen config file to a SSD config dictionary. This dictionary can be saved as a JSON file using the JSON package and &#39;JSON.print(file, config, 4)&#39;. The &#39;detector_name&#39; is set to &quot;Public Inverted Coax&quot; by default to inherit the colour scheme. ...</p><p><strong>Arguments</strong></p><ul><li><code>config::Dict</code>: dictionary containing SigGen parameters (output of readsiggen()).</li><li><code>units::Dict</code>: units used in SigGen file (set to &#39;mm&#39;, &#39;deg&#39;, &#39;V&#39; and &#39;K&#39;).</li><li><code>detector_name::String</code>: name of the detector.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/SolidStateDetector/SigGenInterface.jl#L104-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, CS} where CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate!( sim::Simulation{T};  
                refinement_limits = [0.2, 0.1, 0.05],
                min_tick_distance::Union{Missing, length_unit, Tuple{length_unit, angle_unit, length_unit}} = missing,
                max_tick_distance::Union{Missing, length_unit, Tuple{length_unit, angle_unit, length_unit}} = missing,
                max_distance_ratio::Real = 5,
                verbose::Bool = false,
                use_nthreads::Int = Base.Threads.nthreads(),
                sor_consts::Union{Missing, &lt;:Real, Tuple{&lt;:Real,&lt;:Real}} = missing,
                max_n_iterations::Int = -1,
                depletion_handling::Bool = false, 
                convergence_limit::Real = 1e-7 ) where {T &lt;: SSDFloat}</code></pre><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>2e-6</code> (times bias voltage).</li><li><code>refinement_limits</code>: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the i-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid to fine.   Default is 1e-5 for linear axes and <code>0.25 * r_max</code> for the polar axis in case of a cylindrical grid.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is false.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>-1</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L880-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, S, TGW, AT} where {TGW, AT}, Int64, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, S, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}" href="#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T, 3, 4, S, TGW, AT} where {TGW, AT}, Int64, Val{even_points}, Val{depletion_handling_enabled}, Val{_is_weighting_potential}, Val{only_2d}}} where {T, S, even_points, depletion_handling_enabled, _is_weighting_potential, only_2d}"><code>SolidStateDetectors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing</code></pre><p>Loop over <code>even</code> grid points. A point is <code>even</code> if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -&gt; rbpotential[ inds..., rbi ]).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/PotentialSimulation/SimulationAlgorithms/Cylindrical.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and updates it until it has converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L415-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and updates it until it has converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/Simulation/Simulation.jl#L505-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry" href="#SolidStateDetectors.ConstructiveSolidGeometry"><code>SolidStateDetectors.ConstructiveSolidGeometry</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>module ConstructiveSolidGeometry</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/ConstructiveSolidGeometry.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Box" href="#SolidStateDetectors.ConstructiveSolidGeometry.Box"><code>SolidStateDetectors.ConstructiveSolidGeometry.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box{T, CO} &lt;: AbstractVolumePrimitive{T}</code></pre><p>T: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive &lt;-&gt; whether surface belongs to it or not</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/VolumePrimitives/Box.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGDifference{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>a &amp;&amp; !b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/CSG.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGIntersection{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>a &amp;&amp; b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/CSG.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGUnion{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>a || b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/CSG.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint" href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CartesianPoint{T} &lt;: AbstractCoordinatePoint{T, Cartesian}</code></pre><ul><li><code>x</code>: x-coordinate in meter</li><li><code>y</code>: y-coordinate in meter</li><li><code>z</code>: z-coordinate in meter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/PointsAndVectors/Points.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector" href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CartesianVector{T} &lt;: AbstractCoordinateVector{T, Cartesian}</code></pre><ul><li><code>x</code>: x-component in meter</li><li><code>y</code>: y-component in meter</li><li><code>z</code>: z-component in meter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/PointsAndVectors/Vectors.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Cone" href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>SolidStateDetectors.ConstructiveSolidGeometry.Cone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Cone{T,CO,TR,TP} &lt;: AbstractVolumePrimitive{T, CO}</code></pre><p>T: Type of values, e.g. Float64 CO: ClosedPrimitive or OpenPrimitive &lt;-&gt; whether surface belongs to it or not</p><ul><li><code>r::TR</code>: <ul><li>TR = Real -&gt; Cylinder</li><li>TR = (Real, Real) -&gt; Tube (r<em>in = r[1], r</em>out = r[2])</li><li>TR = ((Real,), (Real,)) Solid widening Cylinder  -&gt; (r<em>bot = r[1][1], r</em>top = r[1][2])</li><li>TR = ((Real,Real), (Real,Real)) Solid widening Tube -&gt;</li></ul></li></ul><p>(r<em>bot</em>in = r[1][1], r<em>bot</em>out = r[1][2], r<em>top</em>in = r[2][1], r<em>top</em>out = r[2][2])     * TR = (Nothing, (Real,Real)) Cone -&gt; (r<em>bot</em>in = r<em>bot</em>out = 0, r<em>top</em>in = r[2][1], r<em>top</em>out = r[2][2])     * TR = ((Real,Real), Nothing) Cone -&gt; (r<em>bot</em>in = r[1][1], r<em>bot</em>out = r[1][2], r<em>top</em>in = r<em>top</em>out = 0)     * ... (+ elliptical cases -&gt; (a, b))     * Not all are implemented yet</p><ul><li><code>φ::TP</code>: <ul><li>TP = Nothing &lt;-&gt; Full in φ</li><li>...</li></ul></li><li><code>hZ::T</code>: half height/length of the cone</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/VolumePrimitives/Cone.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle" href="#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConeMantle{T,TR,TP,D} &lt;: AbstractSurfacePrimitive{T}</code></pre><p>T: Type of values, e.g. Float64</p><ul><li><code>r::TR</code>: <ul><li>TR = Real -&gt; Cylinder Mantle (a = b = r)</li><li>TR = (Real, Real) -&gt; Cone Mantle (r<em>bot = r[1], r</em>top = r[2]) </li><li>TR = ((Real,), (Real,)) -&gt; Elliptical Cylinder Mantle (a = r[1][1], b = r[2][1])</li><li>TR = ((Real, Real),(Real, Real)) -&gt; Elliptical Cone Mantle </li></ul></li></ul><p>(a<em>in = r[1][1], a</em>out = r[1][2], b<em>in = r[2][1], b</em>out = r[2][2])     * Not all are implemented yet</p><ul><li><p><code>φ::TP</code>: </p><ul><li>TP = Nothing &lt;-&gt; Full in φ</li><li>...</li></ul></li><li><p><code>hZ::T</code>: half hight/length of the cone mantle</p></li><li><p><code>D</code>: <code>:inwards</code> or <code>:outwards</code>: Whethe the normal points inside or outside</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/ConeMantle.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint" href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalPoint{T} &lt;: AbstractCoordinatePoint{T, Cylindrical}</code></pre><ul><li><code>r</code>: Radius in meter</li><li><code>φ</code>: Polar angle in radians. φ == 0 &lt;=&gt; Parallel to x-axis of cartesian coordinate system.&quot;</li><li><code>z</code>: z-coordinate in meter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/PointsAndVectors/Points.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector" href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalVector{T} &lt;: AbstractCoordinateVector{T, Cylindrical}</code></pre><ul><li><code>r</code>: Radius in meter</li><li><code>φ</code>: Polar angle in radians. φ == 0 &lt;=&gt; Parallel to x-axis of cartesian coordinate system.&quot;</li><li><code>z</code>: z-coordinate in meter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/PointsAndVectors/Vectors.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Ellipse" href="#SolidStateDetectors.ConstructiveSolidGeometry.Ellipse"><code>SolidStateDetectors.ConstructiveSolidGeometry.Ellipse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ellipse{T,TR} &lt;: AbstractLinePrimitive{T}</code></pre><ul><li><code>r::TR</code>: <ul><li>TR = Real -&gt; Circle (a = b = r)</li><li>TR = (Real, Real) -&gt; Circular Annulus (r<em>in = r[1], r</em>out = r[2])</li><li>TR = ((Real,), (Real,)) -&gt; Ellipse (a = r[1][1], b = r[2][1])</li><li>TR = ((Real, Real),(Real, Real)) -&gt; Elliptical Annulus </li></ul></li></ul><p>(a<em>in = r[1][1], a</em>out = r[1][2], b<em>in = r[2][1], b</em>out = r[2][2])     * Not all are implemented yet</p><ul><li><code>φ::TP</code>: <ul><li>TP = Nothing &lt;-&gt; Full in φ</li><li>...</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/LinePrimitives/Ellipse.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface" href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EllipticalSurface{T,TR,TP} &lt;: AbstractSurfacePrimitive{T}</code></pre><ul><li><code>r::TR</code>: <ul><li>TR = Real -&gt; Full Circle (a = b = r)</li><li>TR = (Real, Real) -&gt; Circular Annulus (r<em>in = r[1], r</em>out = r[2])</li><li>TR = ((Real,), (Real,)) -&gt; Full Ellipse (a = r[1][1], b = r[2][1])</li><li>TR = ((Real, Real),(Real, Real)) -&gt; Elliptical Annulus </li></ul></li></ul><p>(a<em>in = r[1][1], a</em>out = r[1][2], b<em>in = r[2][1], b</em>out = r[2][2])     * Not all are implemented yet</p><ul><li><code>φ::TP</code>: <ul><li>TP = Nothing &lt;-&gt; Full in φ</li><li>...</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipticalSurface.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.extreme_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extreme_points(es::AbstractPrimitive{T}) where {T}</code></pre><p>General implementation for all primitives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/ConstructiveSolidGeometry.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}</code></pre><p>The function will always return 2 CartesianPoint&#39;s. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN&#39;s as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/ConeMantle.jl#L87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(cm::EllipsoidMantle{T,T}, l::Line{T}) where {T}</code></pre><p>The function will always return 2 CartesianPoint&#39;s. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN&#39;s as there coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipsoidMantle.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(cm::EllipsoidMantle{T,NTuple{3,T}}, l::Line{T}) where {T}</code></pre><p>The function will always return 2 CartesianPoint&#39;s. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN&#39;s as there coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipsoidMantle.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(tm::TorusMantle{T}, l::Line{T}) where {T}</code></pre><p>The function will always return 4 CartesianPoint&#39;s. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN&#39;s as there coordinates.</p><p>Solve: <code>solve (sqrt((L1 + λ*D1)^2 + (L2 + λ*D2)^2)-R)^2 + (L3 + λ*D3)^2 = r^2 for λ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/TorusMantle.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial-Union{Tuple{T}, NTuple{4, T}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial-Union{Tuple{T}, NTuple{4, T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.roots_of_4th_order_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots_of_4th_order_polynomial(a::T, b::T, c::T, d::T, e::T)</code></pre><p>Calculate the 4 (possible) roots of <code>x^4 + ax^3 + bx^2 + cx + d = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/edb5b13ef8a4ff6a033e4d187ad1c44b1abb51d5/src/ConstructiveSolidGeometry/SurfacePrimitives/TorusMantle.jl#L90-L94">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../LICENSE/">LICENSE »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Wednesday 21 July 2021 13:14">Wednesday 21 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
